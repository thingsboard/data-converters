{
  "name": "Loriot Uplink Converter for Micro Bluetooth Gateway",
  "type": "UPLINK",
  "debugMode": false,
  "debugSettings": {
    "failuresEnabled": false,
    "allEnabled": false,
    "allEnabledUntil": 0
  },
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "// decoder\r\nfunction decodeUplink(input) {\r\n  // type\r\n  var uplinkType = (input[0] >> 4) & 0x0f;\r\n\r\n  switch (uplinkType) {\r\n    case 0x01:\r\n      return decodeRegistration(input) ;\r\n\r\n    case 0x02:\r\n      return decodeHeartbeat(input) ;\r\n\r\n    case 0x03:\r\n      return decodeDeviceReportRule(input) ;\r\n\r\n    case 0x04:\r\n      return decodeGNSSPosition(input) ;\r\n\t  \r\n    case 0x05:\r\n      return decodeWaterLevelDetection(input) ;\r\n\r\n    case 0x08:\r\n      return decodeDeviceType1(input) ;\r\n\r\n    case 0x09:\r\n      return decodeDeviceType2(input) ;\r\n\r\n    case 0x0a:\r\n      return decodeDeviceType3(input) ;\r\n\r\n    case 0x0e:\r\n      return decodeMultiDeviceTypeMessage(input) ;\r\n\r\n    case 0x0f:\r\n      return decodeAcknowledgment(input) ;\r\n\r\n    default:\r\n      return null;\r\n  }\r\n}\r\n\r\n// type: 0x1 Registration\r\nfunction decodeRegistration(bytes) {\r\n  var data = {};\r\n  data.type = \"Registration\";\r\n  // adr\r\n  data.adr = ((bytes[0] >> 3) & 0x1) == 0 ? \"OFF\" : \"ON\";\r\n  // mode\r\n  data.mode = bytes[0] & 0x07;\r\n  // loRaWANBand\r\n  var loRaWANBandValue = bytes[1];\r\n  if (loRaWANBandValue == 0x00) {\r\n    data.loRaWANBand = \"KR920\";\r\n  } else if (loRaWANBandValue == 0x01) {\r\n    data.loRaWANBand = \"AU915\";\r\n  } else if (loRaWANBandValue == 0x04) {\r\n    data.loRaWANBand = \"CN470\";\r\n  } else if (loRaWANBandValue == 0x08) {\r\n    data.loRaWANBand = \"AS923\";\r\n  } else if (loRaWANBandValue == 0x10) {\r\n    data.loRaWANBand = \"EU433\";\r\n  } else if (loRaWANBandValue == 0x20) {\r\n    data.loRaWANBand = \"EU868\";\r\n  } else if (loRaWANBandValue == 0x40) {\r\n    data.loRaWANBand = \"US915\";\r\n  }\r\n  // power\r\n  data.power = ((bytes[2] >> 3) & 0x1f) + \"dBm\";\r\n  // continuousBleReceiveEnable\r\n  data.continuousBleReceiveEnable =\r\n    ((bytes[2] >> 1) & 0x1) == 0 ? \"Disable\" : \"Enable\";\r\n  // dr\r\n  data.dr = (bytes[3] >> 4) & 0x0f;\r\n  // positionReportInterval\r\n  data.positionReportInterval =\r\n    (((bytes[4] << 8) & 0xff00) | (bytes[5] & 0xff)) * 5 + \"s\";\r\n  // heartbeatInterval\r\n  data.heartbeatInterval = bytes[6] * 30 + \"s\";\r\n  // bleReceivingDuration\r\n  data.bleReceivingDuration = bytes[7] + \"s\";\r\n  // networkReconnectionInterval\r\n  data.networkReconnectionInterval = bytes[8] * 5 + \"min\";\r\n  return data;\r\n}\r\n\r\n// type: 0x2 Heartbeat\r\nfunction decodeHeartbeat(bytes) {\r\n  var data = {};\r\n  // type\r\n  data.type = \"Heartbeat\";\r\n  // battery\r\n  var batteryValue = bytes[1];\r\n  if (batteryValue > 100) {\r\n    data.battery = bytes[1] / 100 + 1.5 + \"V\";\r\n  } else {\r\n    data.battery = bytes[1] + \"%\";\r\n  }\r\n  // rssi\r\n  data.rssi = bytes[2] * -1 + \"dBm\";\r\n  // snr\r\n  data.snr = (((bytes[3] << 8) & 0xff00) | (bytes[4] & 0xff)) / 100 + \"dB\";\r\n  // version\r\n  data.version = ((bytes[5] << 8) & 0xff00) | (bytes[6] & 0xff);\r\n  // chargeState\r\n  var chargeStateValue = bytes[7] & 0xff;\r\n  if (chargeStateValue == 0x00) {\r\n    data.chargeState = \"Not charging\";\r\n  } else if (chargeStateValue == 0x50) {\r\n    data.chargeState = \"Charging\";\r\n  } else if (chargeStateValue == 0x60) {\r\n    data.chargeState = \"Charging completed\";\r\n  }\r\n  return data;\r\n}\r\n\r\n// type: 0x3 DeviceReportRule\r\nfunction decodeDeviceReportRule(bytes) {\r\n  var data = {};\r\n  data.type = \"DeviceReportRule\";\r\n  data.deviceTypeQuantity = bytes[1] & 0xff;\r\n  data.deviceTypeId = (bytes[2] >> 4) & 0x0f;\r\n  data.filterAndDataBlockQuantity = bytes[2] & 0x0f;\r\n  var filterBlock = [];\r\n  var dataBlock = [];\r\n  var macBlock = [];\r\n  var index = 3;\r\n  for (var i = 0; i < data.filterAndDataBlockQuantity; i++) {\r\n    var ruleType = bytes[index++] & 0xff;\r\n    var startAddress = bytes[index++] & 0xff;\r\n    var endAddress = bytes[index++] & 0xff;\r\n    var filter = {};\r\n    if (ruleType == 1) {\r\n      filter.ruleType = \"FilterBlock\";\r\n      filter.startAddress = byteToHex(startAddress);\r\n      filter.endAddress = byteToHex(endAddress);\r\n      var len = endAddress - startAddress;\r\n      var filterValue = \"\";\r\n      for (var j = 0; j < len + 1; j++) {\r\n        filterValue += byteToHex(bytes[index + j]);\r\n      }\r\n      filter.value = filterValue;\r\n      index = index + (endAddress - startAddress + 1);\r\n      filterBlock.push(filter);\r\n    } else if (ruleType == 2) {\r\n      filter.ruleType = \"DataBlock\";\r\n      filter.startAddress = byteToHex(startAddress);\r\n      filter.endAddress = byteToHex(endAddress);\r\n      dataBlock.push(filter);\r\n    } else if (ruleType == 3) {\r\n      filter.ruleType = \"MACBlock\";\r\n      filter.startAddress = byteToHex(startAddress);\r\n      filter.endAddress = byteToHex(endAddress);\r\n      macBlock.push(filter);\r\n    }\r\n  }\r\n  data.filterBlock = filterBlock;\r\n  data.dataBlock = dataBlock;\r\n  data.macBlock = macBlock;\r\n  return data;\r\n}\r\n\r\n// type: 0x04 GNSSPosition\r\nfunction decodeGNSSPosition(bytes) {\r\n  var data = {};\r\n  data.type = \"GNSSPosition\";\r\n  // gnssState\r\n  data.gnssState = (bytes[0] & 0x01) == 0 ? \"Success\" : \"Fail\";\r\n  // longitude\r\n  var longitude =\r\n    (bytes[1] << 24) | (bytes[2] << 16) | (bytes[3] << 8) | bytes[4];\r\n  data.longitude = hex2float(longitude);\r\n  // latitude\r\n  var latitude =\r\n    (bytes[5] << 24) | (bytes[6] << 16) | (bytes[7] << 8) | bytes[8];\r\n  data.latitude = hex2float(latitude);\r\n  // time\r\n  var time =\r\n    (bytes[9] << 24) | (bytes[10] << 16) | (bytes[11] << 8) | bytes[12];\r\n  data.time = time;\r\n\r\n  return data;\r\n}\r\n\r\n// type: 0x5 WaterLevelDetection\r\nfunction decodeWaterLevelDetection(bytes) {\r\n\tvar data = {};\r\n\t// type\r\n\tdata.type = \"WaterLevelDetection\";\r\n\tdata.waterLevel = (((bytes[1] << 8) & 0xff00) | (bytes[2] & 0xff)) + \"mm\";\r\n\treturn data;\r\n}\r\n\r\n// type: 0x8 DeviceType1\r\nfunction decodeDeviceType1(bytes) {\r\n  var data = {\r\n    type: \"DeviceType1\",\r\n    number: bytes[0] & 0x0F\r\n  };\r\n\r\n  var index = 1;\r\n  for (var i = 0; i < data.number; i++) {\r\n    // 使用 parseBytesToInt 解析 major 和 minor\r\n    var major = intToHex(parseBytesToInt(bytes, index, 2, true), true, false);\r\n    var minor = intToHex(parseBytesToInt(bytes, index + 2, 2, true), true, false);\r\n    // 有符号 rssi\r\n    var rssi = parseBytesToInt(bytes, index + 4, 1, true) - 256 + \"dBm\";\r\n\r\n    data[\"beacon\" + (i + 1)] = padStart(major, 4, \"0\") + padStart(minor, 4, \"0\");\r\n    data[\"rssi\" + (i + 1)] = rssi;\r\n\r\n    index = index + 5;\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n// type: 0x9 DeviceType2\r\nfunction decodeDeviceType1(bytes) {\r\n  var data = {\r\n    type: \"DeviceType2\",\r\n    number: bytes[0] & 0x0F\r\n  };\r\n\r\n  var index = 1;\r\n  for (var i = 0; i < data.number; i++) {\r\n    // 使用 parseBytesToInt 解析 major 和 minor\r\n    var major = intToHex(parseBytesToInt(bytes, index, 2, true), true, false);\r\n    var minor = intToHex(parseBytesToInt(bytes, index + 2, 2, true), true, false);\r\n    // 有符号 rssi\r\n    var rssi = parseBytesToInt(bytes, index + 4, 1, true) - 256 + \"dBm\";\r\n\r\n    data[\"beacon\" + (i + 1)] = padStart(major, 4, \"0\") + padStart(minor, 4, \"0\");\r\n    data[\"rssi\" + (i + 1)] = rssi;\r\n\r\n    index = index + 5;\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n// type: 0xa DeviceType3\r\nfunction decodeDeviceType1(bytes) {\r\n  var data = {\r\n    type: \"DeviceType3\",\r\n    number: bytes[0] & 0x0F\r\n  };\r\n\r\n  var index = 1;\r\n  for (var i = 0; i < data.number; i++) {\r\n    // 使用 parseBytesToInt 解析 major 和 minor\r\n    var major = intToHex(parseBytesToInt(bytes, index, 2, true), true, false);\r\n    var minor = intToHex(parseBytesToInt(bytes, index + 2, 2, true), true, false);\r\n    // 有符号 rssi\r\n    var rssi = parseBytesToInt(bytes, index + 4, 1, true) - 256 + \"dBm\";\r\n\r\n    data[\"beacon\" + (i + 1)] = padStart(major, 4, \"0\") + padStart(minor, 4, \"0\");\r\n    data[\"rssi\" + (i + 1)] = rssi;\r\n\r\n    index = index + 5;\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n// type: 0xe MultiDeviceTypeMessage\r\nfunction decodeMultiDeviceTypeMessage(bytes) {\r\n  var data = {\r\n    type: \"MultiDeviceTypeMessage\",\r\n    number: bytes[0] & 0x0f\r\n  };\r\n\r\n  for (var i = 0; i < data.number; i++) {\r\n    var index = 1 + 6 * i;\r\n    var deviceTypeId = bytes[index];\r\n\r\n    var major = intToHex(parseBytesToInt(bytes, index + 1, 2, true), true, false);\r\n    var minor = intToHex(parseBytesToInt(bytes, index + 3, 2, true), true, false);\r\n    var rssi = parseBytesToInt(bytes, index + 5, 1, true) - 256 + \"dBm\";\r\n\r\n    data[\"deviceTypeId\" + (i + 1)] = deviceTypeId;\r\n    data[\"beacon\" + (i + 1)] = padStart(major, 4, \"0\") + padStart(minor, 4, \"0\");\r\n    data[\"rssi\" + (i + 1)] = rssi;\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n// type: 0xf Acknowledgment\r\nfunction decodeAcknowledgment(bytes) {\r\n  var data = {};\r\n  data.type = \"Acknowledgment\";\r\n  data.result = (bytes[0] & 0x0f) == 0 ? \"Success\" : \"Failure\";\r\n  data.msgId = intToHex(parseBytesToInt(bytes, 1, 1, true), true, false);\r\n  \r\n  return data;\r\n}\r\n\r\nfunction byteToHex(value) {\r\n  return padStart(value, 2, \"0\");\r\n}\r\n\r\nfunction hex2float(num) {\r\n  var sign = num & 0x80000000 ? -1 : 1;\r\n  var exponent = ((num >> 23) & 0xff) - 127;\r\n  var mantissa = 1 + (num & 0x7fffff) / 0x7fffff;\r\n  return sign * mantissa * Math.pow(2, exponent);\r\n}\r\n\r\n\r\n// TBEL\r\nvar deviceData = decodeToJson(payload);\r\nvar deviceName = deviceData.EUI;\r\nvar deviceType = \"deviceProfile\";\r\n\r\nvar result = {\r\n  deviceName: deviceName,\r\n  deviceType: deviceType,\r\n  telemetry: decodeUplink(hexToBytes(deviceData.data)),\r\n};\r\n\r\nfunction decodeToString(payload) {\r\n  return String.fromCharCode.apply(String, payload);\r\n}\r\n\r\nfunction decodeToJson(payload) {\r\n  var str = decodeToString(payload);\r\n  var data = JSON.parse(str);\r\n  return data;\r\n}\r\n\r\nreturn result;",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "manufacturer"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}