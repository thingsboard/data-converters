{
  "name": "Things Stack Community Uplink Converter for MClimate 16ASPM",
  "type": "UPLINK",
  "integrationType": "TTN",
  "debugMode": false,
  "debugSettings": {
    "failuresEnabled": true,
    "allEnabled": false,
    "allEnabledUntil": 0
  },
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "function decodePayload(input) {\n    var result = { attributes: {}, telemetry: {} };\n    var timestamp = metadata.ts;\n    var values = {};\n\n    if (parseBytesToInt(input, 0, 1) === 1) {\n        values = handleKeepalive(input, values);\n    } else {\n        values = handleResponse(input, values);\n        var tail = input.slice(-12);\n        values = handleKeepalive(tail, values);\n    }\n\n    result.telemetry = {\n        ts: timestamp,\n        values: values\n    };\n    return result;\n}\n\nfunction handleKeepalive(bytes, data) {\n    data.internalTemperature = parseBytesToInt(bytes, 1, 1);\n    data.relayState = (parseBytesToInt(bytes, 11, 1) === 0x01 ? \"ON\" : \"OFF\");\n\n    var energy = parseBytesToInt(bytes, 2, 4);\n    var power  = parseBytesToInt(bytes, 6, 2);\n    var acCurr = parseBytesToInt(bytes, 9, 2);\n    var acVolt = parseBytesToInt(bytes, 8, 1);\n\n    data.energy_kWh = energy / 1000;\n    data.power_W = power;\n    data.acVoltage_V = acVolt;\n    data.acCurrent_mA = acCurr;\n\n    return data;\n}\n\nfunction handleResponse(bytes, data) {\n    var commands = [];\n\n    var len = bytes.length - 12;\n    \n    for (var i = 0; i < len; i++) {\n        var b = bytes[i] & 0xFF;\n        var h = intToHex(b);\n    \n        if (h.length == 1) {\n            h = '0' + h;\n        } \n        commands.add(h);\n    }\n\n    for (var i = 0; i < commands.length; i++) {\n        var cmd = commands[i];\n        switch (cmd) {\n            case '04':\n                data.deviceVersions = {\n                    hardware: parseInt(commands[i+1], 16),\n                    software: parseInt(commands[i+2], 16)\n                };\n                i += 2;\n                break;\n            case '12':\n                data.keepAliveTime = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '19':\n                data.joinRetryPeriod = parseInt(commands[i+1], 16) * 5 / 60;\n                i += 1;\n                break;\n            case '1b':\n                data.uplinkType = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '1d':\n                var wdpC  = (commands[i+1] != '00') ? parseInt(commands[i+1], 16) : false;\n                var wdpUc = (commands[i+2] != '00') ? parseInt(commands[i+2], 16) : false;\n                data.watchDogParams = { wdpC: wdpC, wdpUc: wdpUc };\n                i += 2;\n                break;\n            case '1f':\n                data.overheatingThreshold = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '21':\n                data.overvoltageThreshold = parseInt(commands[i+1] + commands[i+2], 16);\n                i += 2;\n                break;\n            case '23':\n                data.overcurrentThreshold = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '25':\n                data.overpowerThreshold = parseInt(commands[i+1] + commands[i+2], 16);\n                i += 2;\n                break;\n            case '5a':\n                data.afterOverheatingProtectionRecovery = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '5c':\n                data.ledIndicationMode = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '5d':\n                data.manualChangeRelayState = (parseInt(commands[i+1], 16) === 0x01);\n                i += 1;\n                break;\n            case '5f':\n                data.relayRecoveryState = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '60':\n                data.overheatingEvents = {\n                    events:      parseInt(commands[i+1], 16),\n                    temperature: parseInt(commands[i+2], 16)\n                };\n                i += 2;\n                break;\n            case '61':\n                data.overvoltageEvents = {\n                    events:  parseInt(commands[i+1], 16),\n                    voltage: parseInt(commands[i+2] + commands[i+3], 16)\n                };\n                i += 3;\n                break;\n            case '62':\n                data.overcurrentEvents = {\n                    events:  parseInt(commands[i+1], 16),\n                    current: parseInt(commands[i+2] + commands[i+3], 16)\n                };\n                i += 3;\n                break;\n            case '63':\n                data.overpowerEvents = {\n                    events: parseInt(commands[i+1], 16),\n                    power:  parseInt(commands[i+2] + commands[i+3], 16)\n                };\n                i += 3;\n                break;\n            case '70':\n                data.overheatingRecoveryTime = parseInt(commands[i+1] + commands[i+2], 16);\n                i += 2;\n                break;\n            case '71':\n                data.overvoltageRecoveryTime = parseInt(commands[i+1] + commands[i+2], 16);\n                i += 2;\n                break;\n            case '72':\n                data.overcurrentRecoveryTemp = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case '73':\n                data.overpowerRecoveryTemp = parseInt(commands[i+1], 16);\n                i += 1;\n                break;\n            case 'b1':\n                data.relayState = (parseInt(commands[i+1], 16) === 0x01);\n                i += 1;\n                break;\n            case 'a0':\n                var addrRaw = commands[i+1] + commands[i+2] + commands[i+3] + commands[i+4];\n                data.fuota = {\n                    fuota_address: parseInt(addrRaw, 16),\n                    fuota_address_raw: addrRaw\n                };\n                i += 4;\n                break;\n            default:\n                break;\n        }\n    }\n    return data;\n}\n\nvar result = {};\n\nif (payload != null && payload.length > 0) {\n    result = decodePayload(payload);\n}\n\nreturn result;",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "eui",
      "devAddr",
      "fPort",
      "bandwidth",
      "spreadingFactor",
      "codeRate",
      "frequency",
      "hardwareVersion",
      "firmwareVersion",
      "tenantId"
    ],
    "type": "DEVICE",
    "name": "16ASPM $eui",
    "profile": "$applicationId",
    "label": "$deviceId",
    "customer": "",
    "group": "",
    "telemetry": null,
    "attributes": [
      "eui",
      "devAddr",
      "fPort",
      "bandwidth",
      "spreadingFactor",
      "codeRate",
      "frequency",
      "tenantId",
      "joinEui",
      "deviceId",
      "clusterId",
      "clusterAddress",
      "netId",
      "applicationId"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false,
  "converterVersion": 2
}