{
  "name": "Loriot Uplink Converter for Milesight WS202",
  "type": "UPLINK",
  "integrationType": "LORIOT",
  "debugMode": false,
  "debugSettings": {
    "failuresEnabled": true,
    "allEnabled": false,
    "allEnabledUntil": 0
  },
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "/**\n * Decodes the incoming payload and returns a structured object containing telemetry data and attributes.\n *\n * @param {number[]} input - The raw payload received as an array of bytes.\n * @returns {Object} output - The structured output with decoded telemetry and attributes.\n */\n\nfunction decodePayload(input) {\n    // Initialize the output object with empty attributes and telemetry for clarity.\n    var result = { attributes: {}, telemetry: {}};\n\n    // Decode serial number (SN) from the first 4 bytes of the payload.\n    // Press '?' icon in the top right corner to learn more about built in helper functions and capabilities.\n    result.attributes.sn = parseBytesToInt(input, 0, 4);\n\n    // Extract the timestamp from metadata (represented in milliseconds).\n    var timestamp = metadata.ts; // ts from the incoming message.\n\n    // Initialize an object to store decoded key/value telemetry data.\n    var values = {};\n\n    // Decode battery level from the 5th byte of the payload.\n    values.battery = parseBytesToInt(input, 4, 1);\n\n    // Decode temperature from the 6th and 7th bytes of the payload (divided by 100).\n    values.temperature = parseBytesToInt(input, 5, 2) / 100.0;\n\n    // Decode saturation from the 8th byte of the payload.\n    values.saturation = parseBytesToInt(input, 7, 1);\n\n    // Combine the timestamp with values and add it to the telemetry.\n    result.telemetry = {\n        ts: timestamp,\n        values: values\n    };\n\n    // Return the fully constructed output object.\n    return result;\n    // Same logic, less code:\n    // return {\n    //     attributes: {\n    //         sn: parseBytesToInt(input, 0, 4)\n    //     },\n    //     telemetry: {\n    //         ts: metadata.ts,\n    //         values: {\n    //             battery: parseBytesToInt(input, 4, 1),\n    //             temperature: parseBytesToInt(input, 5, 2) / 100.0,\n    //             saturation: parseBytesToInt(input, 7, 1)\n    //         }\n    //     }\n    // };\n}\n\nvar result = decodePayload(payload);\n// Uncomment this code block to overwrite values set in the main configuration window. Useful if you extract device/asset/customer/group names from the payload;\n// result.type = 'DEVICE'; // Entity type allows you to choose type of created entity. Can be 'DEVICE' or 'ASSET'.\n// result.name = 'Temperature Sensor'; // Device or asset name (the value must be unique)\n// result.profile = 'IndustrialSensorProfile'; // Device or asset profile name.\n// result.customer = 'MyCustomer'; // If customer is not null - created entity will be assigned to customer with such name.\n// result.group = 'SensorsGroup'; // If group is not null - created entity will be added to the entity group with such name.\n\n// Return the final result object.\nreturn result;\n\n/**\n * Parse a slice of bytes from an array into an integer (big-endian).\n *\n * @param {number[]} input - The array of bytes.\n * @param {number} offset - The starting index.\n * @param {number} length - The number of bytes to convert.\n * @returns {number} - The resulting integer.\n */\nfunction parseBytesToInt(input, offset, length) {\n  var result = 0;\n  for (var i = offset; i < offset + length; i++) {\n    result = (result << 8) | (input[i] & 0xFF);\n  }\n  return result;\n}",
    "tbelDecoder": "/**\n * Decodes the incoming payload and returns a structured object containing telemetry data and attributes.\n *\n * @param {byte[]} input - The raw payload received as an array of bytes.\n * @returns {Object} output - The structured output with decoded telemetry and attributes.\n */\n\nfunction decodePayload(input) {\n    // Initialize the output object with empty attributes and telemetry for clarity.\n    var result = { attributes: {}, telemetry: {}};\n\n\n    // Extract the timestamp from metadata (represented in milliseconds).\n    var timestamp = metadata.ts; // ts is the timestamp parsed from the incoming message's time, or returns the current time if it cannot be parsed.\n\n    var values = {};\n    for (var i = 0; i < input.length; ) {\n        var channel_id = input[i++] & 0xff;\n        var channel_type = input[i++] & 0xff;\n        // IPSO VERSION\n        if (channel_id === 0xff && channel_type === 0x01) {\n            values.ipso_version = readProtocolVersion(input[i]);\n            i += 1;\n        }\n        // HARDWARE VERSION\n        else if (channel_id === 0xff && channel_type === 0x09) {\n            values.hardware_version = readHardwareVersion(input.slice(i, i + 2));\n            i += 2;\n        }\n        // FIRMWARE VERSION\n        else if (channel_id === 0xff && channel_type === 0x0a) {\n            values.firmware_version = readFirmwareVersion(input.slice(i, i + 2));\n            i += 2;\n        }\n        // TSL VERSION\n        else if (channel_id === 0xff && channel_type === 0xff) {\n            values.tsl_version = readTslVersion(input.slice(i, i + 2));\n            i += 2;\n        }\n        // SERIAL NUMBER\n        else if (channel_id === 0xff && channel_type === 0x16) {\n            values.sn = readSerialNumber(input.slice(i, i + 8));\n            i += 8;\n        }\n        // LORAWAN CLASS TYPE\n        else if (channel_id === 0xff && channel_type === 0x0f) {\n            values.lorawan_class = readLoRaWANClass(input[i]);\n            i += 1;\n        }\n        // RESET EVENT\n        else if (channel_id === 0xff && channel_type === 0xfe) {\n            values.reset_event = readResetEvent(1);\n            i += 1;\n        }\n        // DEVICE STATUS\n        else if (channel_id === 0xff && channel_type === 0x0b) {\n            values.device_status = readDeviceStatus(1);\n            i += 1;\n        }\n        // BATTERY\n        if (channel_id === 0x01 && channel_type === 0x75) {\n            values.battery = input[i];\n            i += 1;\n        }\n        // PIR\n        else if (channel_id === 0x03 && channel_type === 0x00) {\n            values.pir = input[i] === 0 ? \"normal\" : \"trigger\";\n            i += 1;\n        }\n        // DAYLIGHT\n        else if (channel_id === 0x04 && channel_type === 0x00) {\n            values.daylight = input[i] === 0 ? \"dark\" : \"light\";\n            i += 1;\n        }\n    }\n\n    // Combine the timestamp with values and add it to the telemetry.\n    result.telemetry = {\n        ts: timestamp,\n        values: values\n    };\n\n    // Return the fully constructed output object.\n    return result;\n}\n\nvar uplinkDataResult = [];\n\nvar result = decodePayload(payload);\n\nuplinkDataResult.push(result);\n\nvar gatewayDeviceNamePrefix = \"Gateway \";\nvar gatewayDeviceType = \"Lora gateway\";\n\nif (metadata.cmd == \"gw\") {\n    foreach( gatewayInfo : metadata.gws ) {\n        var addGatewayInfo = {};\n\n        // You can add some keys manually telemetry\n        addGatewayInfo.rssi = gatewayInfo.rssi;\n        addGatewayInfo.snr = gatewayInfo.snr;\n        // You can add some keys manually telemetry\n        \n        var gatewayInfoMsg = {\n            name: gatewayDeviceNamePrefix + gatewayInfo.gweui,\n            profile: gatewayDeviceType,\n            telemetry: {\n                \"ts\": gatewayInfo.ts,\n                \"values\": addGatewayInfo\n            },\n            attributes: {\n                eui: gatewayInfo.gweui\n            }\n        };\n        uplinkDataResult.add(gatewayInfoMsg);\n    }\n}\n\n// Return the final result object.\nreturn uplinkDataResult;\n\nfunction readProtocolVersion(bytes) {\n    var major = (bytes & 0xf0) >> 4;\n    var minor = bytes & 0x0f;\n    return \"v\" + major + \".\" + minor;\n}\n\nfunction readHardwareVersion(bytes) {\n    var major = bytes[0] & 0xff;\n    var minor = (bytes[1] & 0xff) >> 4;\n    return \"v\" + major + \".\" + minor;\n}\n\nfunction readFirmwareVersion(bytes) {\n    var major = bytes[0] & 0xff;\n    var minor = bytes[1] & 0xff;\n    return \"v\" + major + \".\" + minor;\n}\n\nfunction readTslVersion(bytes) {\n    var major = bytes[0] & 0xff;\n    var minor = bytes[1] & 0xff;\n    return \"v\" + major + \".\" + minor;\n}\n\nfunction readSerialNumber(bytes) {\n    var result = \"\";\n    for (int i = 0; i < bytes.length; i++) {\n        var hex = Integer.toHexString(bytes[i] & 0xFF);\n        if (hex.length() == 1) {\n            hex = \"0\" + hex;\n        }\n        result += hex;\n    }\n    return result;\n}\n\nfunction readLoRaWANClass(type) {\n    switch (type) {\n        case 0: return \"Class A\";\n        case 1: return \"Class B\";\n        case 2: return \"Class C\";\n        case 3: return \"Class CtoB\";\n        default: return null;\n    }\n}\n\nfunction readResetEvent(status) {\n    switch (status) {\n        case 0: return \"normal\";\n        case 1: return \"reset\";\n        default: return null;\n    }\n}\n\nfunction readDeviceStatus(status) {\n    switch (status) {\n        case 0: return \"off\";\n        case 1: return \"on\";\n        default: return null;\n    }\n}\n\nfunction readYesNoStatus(status) {\n    switch (status) {\n        case 0: return \"no\";\n        case 1: return \"yes\";\n        default: return null;\n    }\n}\n\nfunction readPirStatus(status) {\n    switch (status) {\n        case 0: return \"normal\";\n        case 1: return \"trigger\";\n        default: return null;\n    }\n}\n\nfunction readDaylight(status) {\n    switch (status) {\n        case 0: return \"dim\";\n        case 1: return \"bright\";\n        default: return null;\n    }\n}",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "eui",
      "fPort",
      "frequency",
      "dr"
    ],
    "type": "DEVICE",
    "name": "WS202 $eui",
    "profile": "",
    "label": "",
    "customer": "",
    "group": "",
    "telemetry": null,
    "attributes": [
      "eui",
      "fPort",
      "frequency"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false,
  "converterVersion": 2
}