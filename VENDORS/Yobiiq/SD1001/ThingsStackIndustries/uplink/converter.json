{
    "name": "The Things Stack Industries Uplink data converter for Yobiiq SD-1001",
    "type": "UPLINK",
    "debugFailures" : false,
    "debugAll" : true,
    "debugAllUntil": 0,
    "configuration": {
      "scriptLang": "TBEL",
      "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
      "tbelDecoder": "var data = decodeToJson(payload);\r\n\r\nvar deviceName = data.end_device_ids.device_id;\r\nvar deviceType = 'Smoke Detector';\r\nvar groupName = 'Smoke Detectors';\r\n// var customerName = 'Customer A';\r\n// use assetName and assetType instead of deviceName and deviceType\r\n// to automatically create assets instead of devices.\r\n// var assetName = 'Asset A';\r\n// var assetType = 'building';\r\n\r\n\r\n// --- attributes and telemetry objects ---\r\nvar telemetry = {};\r\nvar attributes = {};\r\n// --- attributes and telemetry objects ---\r\n\r\n// --- Timestamp parsing\r\nvar dateString = data.uplink_message.received_at;\r\n// If data is simulated or device doesn't send his own date string - we will use date from upcoming message, set by network server\r\nif ((data.simulated != null && data.simulated) || dateString == null) {\r\n  dateString = data.received_at;\r\n}\r\nvar timestamp = -1;\r\nif (dateString != null) {\r\n  timestamp = new Date(dateString).getTime();\r\n  if (timestamp == -1) {\r\n    var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\r\n    var millisecondsEndIndex = dateString.lastIndexOf('+');\r\n    if (millisecondsEndIndex == -1) {\r\n      millisecondsEndIndex = dateString.lastIndexOf('Z');\r\n    }\r\n    if (millisecondsEndIndex == -1) {\r\n      millisecondsEndIndex = dateString.lastIndexOf('-');\r\n    }\r\n    if (millisecondsEndIndex == -1) {\r\n      if (dateString.length >= secondsSeparatorIndex + 3) {\r\n        dateString = dateString.substring(0, secondsSeparatorIndex + 3);\r\n      }\r\n    } else {\r\n      dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\r\n          dateString.substring(millisecondsEndIndex, dateString.length);\r\n    }\r\n    timestamp = new Date(dateString).getTime();\r\n  }\r\n}\r\n// If we cannot parse timestamp - we will use the current timestamp\r\nif (timestamp == -1) {\r\n  timestamp = Date.now();\r\n}\r\n\r\nvar telemetryData = {};\r\nvar attributesData = {};\r\nattributesData.devEui = data.end_device_ids.dev_eui;\r\nattributesData.devId = data.end_device_ids.device_id;\r\nattributesData.applicationId = data.end_device_ids.application_ids.application_id;\r\n\r\n// empty input uplink\r\nvar input = {\r\n    fPort: null,\r\n    bytes: [],\r\n    variables: null,\r\n};\r\n\r\n// empty decoded uplink\r\nvar up = {\r\n    timestamp : timestamp,\r\n    object: {},\r\n    fPort: null\r\n};\r\n\r\nif(data.uplink_message.f_port != null)\r\n{\r\n    telemetryData.fPort = data.uplink_message.f_port;\r\n    telemetryData.confirmed = data.uplink_message.confirmed;\r\n    telemetryData.fCnt = data.uplink_message.f_cnt;\r\n\r\n    input.fPort = data.uplink_message.f_port;\r\n    input.bytes = hexStringToIntList(base64ToHex(data.uplink_message.frm_payload));\r\n\r\n    // Decode uplink\r\n    up.fPort = input.fPort;\r\n    up.object = decodeUplink(input).data;\r\n}\r\n\r\nvar decoderAttributes = getVersionControl();\r\nvar decoderTelemetry = {};\r\n\r\nforeach(element: up.object.entrySet())\r\n{\r\n    if(element.key == 'warning') {\r\n        decoderAttributes[element.key] = element.value;\r\n    }else if(element.key == 'info')\r\n    {\r\n        decoderAttributes[element.key] = element.value;\r\n    }else{\r\n        decoderTelemetry[element.key] = element.value;\r\n    }\r\n}\r\ntelemetry.putAll(telemetryData);\r\nattributes.putAll(attributesData);\r\ntelemetry.putAll(decoderTelemetry);\r\nattributes.putAll(decoderAttributes);\r\n\r\nvar result = {\r\n    deviceName: deviceName,\r\n    deviceType: deviceType,\r\n    // assetName: assetName,\r\n    // assetType: assetType,\r\n    groupName: groupName,\r\n    attributes: attributes,\r\n    telemetry: {\r\n        ts: timestamp,\r\n        values: telemetry\r\n    }\r\n};\r\n\r\n\r\nreturn result;\r\n\r\n\r\n\r\n/****************************  Yobiiq Decoder *******************************/\r\n\r\nfunction isBasicInformation(bytes, fPort)\r\n{\r\n    if(fPort == 50)\r\n    {\r\n        return true;\r\n    }\r\n    // Example: ff090100 ff0a0102 ff162404152795 ff0f02 ff0b01\r\n    if(bytes[0] == 0xFF &&\r\n        bytes[4] == 0xFF &&\r\n        bytes[8] == 0xFF\r\n    )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction decodeBasicInformation(bytes)\r\n{\r\n    // Configuration constants for device basic info\r\n    var CONFIG_INFO = {\r\n        FPORT     : 50,\r\n        CHANNEL  : 0xFF,\r\n        TYPES    : {\r\n            \"0x09\" : {SIZE : 2, NAME : \"hardwareVersion\", DIGIT: false},\r\n            \"0x0A\" : {SIZE : 2, NAME : \"firmwareVersion\", DIGIT: false},\r\n            \"0x16\" : {SIZE : 5, NAME : \"deviceSerialNumber\", DIGIT: true},\r\n            \"0x0F\" : {SIZE : 1, NAME : \"deviceClass\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Class A\",\r\n                    \"0x01\" : \"Class B\",\r\n                    \"0x02\" : \"Class C\",\r\n                },\r\n            },\r\n            \"0x0B\" : {SIZE : 1, NAME : \"powerEvent\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"AC Power Off\",\r\n                    \"0x01\" : \"AC Power On\",\r\n                },\r\n            },\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n    };\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = 0;\r\n    var type = \"\";\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_INFO.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_INFO.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    while(index < LENGTH)\r\n    {\r\n        channel = bytes[index];\r\n        index = index + 1;\r\n        if(channel != CONFIG_INFO.CHANNEL)\r\n        {\r\n            channel = \"0x\" + byteToEvenHex(channel).toUpperCase();\r\n            exceptedValue = \"0x\" + byteToEvenHex(CONFIG_INFO.CHANNEL).toUpperCase();\r\n            decoded.error = \"channel \"+ channel + \" should be \" + exceptedValue;\r\n            return decoded;\r\n        }\r\n        // Type of basic information\r\n        type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;\r\n        var info = CONFIG_INFO.TYPES[type];\r\n        if(info == null)\r\n        {\r\n            decoded.error = \"can't decode type \"+ type;\r\n            return decoded;\r\n        }\r\n        size = info.SIZE;\r\n        // Decoding\r\n        var value = 0;\r\n        if(size != 0)\r\n        {\r\n            if(info.DIGIT != null)\r\n            {\r\n                if(info.DIGIT == false)\r\n                {\r\n                    // Decode into \"V\" + DIGIT STRING + \".\" DIGIT STRING format\r\n                    value = getDigitStringArrayNoFormat(bytes, index, size);\r\n                    value = \"V\" + value[0] + \".\" + value[1];\r\n                }else\r\n                {\r\n                    // Decode into DIGIT STRING format\r\n                    value = getDigitStringArrayEvenFormat(bytes, index, size).join(\"\");\r\n                    value = parseLong(value, 10);\r\n                }\r\n            }\r\n            else if(info.VALUES != null)\r\n            {\r\n                // Decode into HEX STRING (VALUES specified in CONFIG_INFO)\r\n                value = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n                value = info.VALUES[value];\r\n            }else\r\n            {\r\n                // Decode into DECIMAL format\r\n                value = parseBytesToInt(bytes, index, size);\r\n            }\r\n            decoded[info.NAME] = value;\r\n            index = index + size;\r\n        }\r\n    }\r\n\r\n    return decoded;\r\n}\r\n\r\nfunction decodeDeviceData(bytes)\r\n{\r\n    // Configuration constants for data registers\r\n    var CONFIG_DATA = {\r\n        FPORT   : 8,\r\n        CHANNELS   : {\r\n            \"0x01\" : {SIZE : 1, NAME : \"batteryLevelInPercentage\",},\r\n            \"0x02\" : {SIZE : 1, NAME : \"powerEvent\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"AC Power Off\",\r\n                    \"0x01\" : \"AC Power On\",\r\n                },\r\n            },\r\n            \"0x03\" : {SIZE : 1, NAME : \"lowBatteryAlarm\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Normal\",\r\n                    \"0x01\" : \"Alarm\",\r\n                },\r\n            },\r\n            \"0x04\" : {SIZE : 1, NAME : \"faultAlarm\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Normal\",\r\n                    \"0x01\" : \"Alarm\",\r\n                },\r\n            },\r\n            \"0x05\" : {SIZE : 1, NAME : \"smokeAlarm\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Normal\",\r\n                    \"0x01\" : \"Alarm\",\r\n                },\r\n            },\r\n            \"0x06\" : {SIZE : 1, NAME : \"interconnectAlarm\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Normal\",\r\n                    \"0x01\" : \"Alarm\",\r\n                },\r\n            },\r\n            \"0x07\" : {SIZE : 1, NAME : \"testButtonPressed\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Normal\",\r\n                    \"0x01\" : \"Pushed\",\r\n                },\r\n            },\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n    };\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = \"\";\r\n    var type = 0;\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_DATA.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_DATA.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    while(index < LENGTH)\r\n    {\r\n        // Channel of device data\r\n        channel = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;\r\n        // Type of device data\r\n        type = bytes[index];\r\n        index = index + 1;\r\n\r\n        // No type checking\r\n\r\n        var config = CONFIG_DATA.CHANNELS[channel];\r\n        if(config == null)\r\n        {\r\n            decoded.error = \"can't decode channel \"+ channel;\r\n            return decoded;\r\n        }\r\n        size = config.SIZE;\r\n        // Decoding\r\n        var value = 0;\r\n        if(config.VALUES != null)\r\n        {\r\n            // Decode into STRING (VALUES specified in CONFIG_DATA)\r\n            value = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n            value = config.VALUES[value];\r\n        }else\r\n        {\r\n            // Decode into DECIMAL format\r\n            value = parseBytesToInt(bytes, index, size);\r\n        }\r\n        decoded[config.NAME] = value;\r\n        index = index + size;\r\n    }\r\n\r\n    return decoded;\r\n}\r\n\r\nfunction getDigitStringArrayNoFormat(bytes, index, size)\r\n{\r\n  var hexString = [];\r\n  for(var i=0; i<size; i=i+1)\r\n  {\r\n    hexString.push(Integer.toString(bytes[index+i], 16));\r\n  }\r\n  return hexString\r\n}\r\n\r\nfunction getDigitStringArrayEvenFormat(bytes, index, size)\r\n{\r\n  var hexString = [];\r\n  for(var i=0; i<size; i=i+1)\r\n  {\r\n    hexString.push(byteToEvenHex(bytes[index+i]));\r\n  }\r\n  return hexString;\r\n}\r\n\r\nfunction toEvenHEX(hex)\r\n{\r\n  if(hex.length == 1)\r\n  {\r\n    return \"0\"+hex;\r\n  }\r\n  return hex;\r\n}\r\n\r\nfunction byteToEvenHex(val)\r\n{\r\n    return toEvenHEX(Integer.toString(val, 16));\r\n}\r\n\r\nfunction hexStringToIntList(hexString)\r\n{\r\n    var bytes = [];\r\n    var hexByte = \"\";\r\n    for(var i=0; i<hexString.length; i=i+2)\r\n    {\r\n        hexByte = hexString[i] + hexString[i+1];\r\n        bytes.push(parseHexToInt(hexByte));\r\n    }\r\n    return bytes;\r\n}\r\n\r\n\r\n/************************************************************************************************************/\r\n\r\n// Decode decodes an array of bytes into an object. (ChirpStack v3)\r\n//  - fPort contains the LoRaWAN fPort number\r\n//  - bytes is an array of bytes, e.g. [225, 230, 255, 0]\r\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\r\n// The function must return an object, e.g. {\"temperature\": 22.5}\r\nfunction Decode(fPort, bytes, variables) \r\n{\r\n    var decoded = {};\r\n    if(isBasicInformation(bytes, fPort))\r\n    {\r\n        decoded = decodeBasicInformation(bytes);\r\n    }else\r\n    {\r\n        decoded = decodeDeviceData(bytes);\r\n    }\r\n    return decoded;\r\n}\r\n\r\n// Decode uplink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - bytes = Byte array containing the uplink payload, e.g. [255, 230, 255, 0]\r\n// - fPort = Uplink fPort.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - data = Object representing the decoded payload.\r\nfunction decodeUplink(input) {\r\n    return {\r\n        data: Decode(input.fPort, input.bytes, input.variables)\r\n    };\r\n}\r\n\r\nfunction getVersionControl()\r\n{\r\n    // Version Control\r\n    var VERSION_CONTROL = {\r\n        CODEC : {VERSION: \"1.1.0\", NAME: \"codecVersion\"},\r\n        DEVICE: {MODEL : \"SD-1001\", NAME: \"deviceModel\"},\r\n        PRODUCT: {CODE : \"1002015\", NAME: \"productCode\"},\r\n        MANUFACTURER: {COMPANY : \"YOBIIQ B.V.\", NAME: \"manufacturer\"},\r\n    };\r\n    var decoded = {};\r\n    decoded[VERSION_CONTROL.CODEC.NAME] = VERSION_CONTROL.CODEC.VERSION;\r\n    decoded[VERSION_CONTROL.DEVICE.NAME] = VERSION_CONTROL.DEVICE.MODEL;\r\n    decoded[VERSION_CONTROL.PRODUCT.NAME] = VERSION_CONTROL.PRODUCT.CODE;\r\n    decoded[VERSION_CONTROL.MANUFACTURER.NAME] = VERSION_CONTROL.MANUFACTURER.COMPANY;\r\n    return decoded;\r\n}",
      "encoder": null,
      "tbelEncoder": null,
      "updateOnlyKeys": [
        "manufacturer"
      ]
    },
    "additionalInfo": {
      "description": ""
    },
    "edgeTemplate": false
  }