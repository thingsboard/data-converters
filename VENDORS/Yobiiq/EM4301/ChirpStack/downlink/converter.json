{
  "name": "ChirpStack Downlink data converter for Yobiiq EM43xx series",
  "type": "DOWNLINK",
  "debugMode": true,
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions 'decodeToString' and 'decodeToJson' are already built-in **/\n\nreturn result;",
    "encoder": null,
    "tbelEncoder": "// Process data from incoming message and metadata\r\nvar input = {\r\n    fPort : parseInt(metadata.rc_fPort), // from rule chain\r\n    confirmed : metadata.rc_confirmed === \"true\" ? true : false, // from rule chain\r\n    data : msg,\r\n    variables: null,\r\n    devEui : metadata.cs_devEui, // from client scope\r\n    applicationId: metadata.cs_applicationId, // from client scope\r\n};\r\n\r\n// Result object with encoded downlink payload\r\nvar result = {\r\n\r\n    // downlink data content type: JSON, TEXT or BINARY (base64 format)\r\n    contentType: \"TEXT\",\r\n\r\n    // downlink data\r\n    data: bytesToBase64(encodeDownlink(input).bytes),\r\n\r\n    // Optional metadata object presented in key/value format\r\n    metadata: {\r\n        eui: input.devEui,\r\n        DevEUI: input.devEui,\r\n        fPort: input.fPort,\r\n    }\r\n\r\n};\r\n\r\n\r\nreturn result;\r\n\r\n\r\n/************************************************************************************************************/\r\n\r\n// Encode downlink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - data = Object representing the payload that must be encoded.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - bytes = Byte array containing the downlink payload.\r\nfunction encodeDownlink(input) {\r\n    return {\r\n        bytes: Encode(null, input.data, input.variables)\r\n    };\r\n}\r\n\r\n\r\n/************************************************************************************************************/\r\n\r\n// Encode encodes the given object into an array of bytes. (ChirpStack v3)\r\n//  - fPort contains the LoRaWAN fPort number\r\n//  - obj is an object, e.g. {\"temperature\": 22.5}\r\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\r\n// The function must return an array of bytes, e.g. [225, 230, 255, 0]\r\nfunction Encode(fPort, obj, variables) {\r\n    // Constants for downlink type (Config or Measure)\r\n    var CONFIG_DOWNLINK = {\r\n        TYPE    : \"Type\",\r\n        CONFIG  : \"Config\",\r\n        MEASURE : \"Measure\",\r\n    };\r\n\r\n    if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.CONFIG)\r\n    {\r\n        return encodeDeviceConfiguration(obj[CONFIG_DOWNLINK.CONFIG]);\r\n    }\r\n    else if(obj[CONFIG_DOWNLINK.TYPE] == CONFIG_DOWNLINK.MEASURE)\r\n    {\r\n        return encodePeriodicPackage(obj[CONFIG_DOWNLINK.MEASURE]);\r\n    }\r\n    \r\n    return [];\r\n}\r\n\r\n// Encode downlink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - data = Object representing the payload that must be encoded.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - bytes = Byte array containing the downlink payload.\r\nfunction encodeDownlink(input) {\r\n    return {\r\n        bytes: Encode(null, input.data, input.variables)\r\n    };\r\n}\r\n\r\n/************************************************************************************************************/\r\n\r\n\r\nfunction encodeDeviceConfiguration(configObj)\r\n{\r\n    // Constants for device configuration \r\n    var CONFIG_DEVICE = {\r\n        FPORT : 50,\r\n        CHANNEL : 0xFF,\r\n        TYPES : {\r\n            \"restart\" : {TYPE : 0x0B, SIZE : 1, MIN : 1, MAX : 1,},\r\n            \"primaryCurrentTransformerRatio\" : {TYPE : 0x1E, SIZE : 2, MIN : 0, MAX : 9999,},\r\n            \"secondaryCurrentTransformerRatio\" : {TYPE : 0x1F, SIZE : 1, MIN : 0, MAX : 5,},\r\n            \"primaryVoltageTransformerRatio\" : {TYPE : 0x20, SIZE : 4, MIN : 30, MAX : 500000,},\r\n            \"secondaryVoltageTransformerRatio\" : {TYPE : 0x21, SIZE : 2, MIN : 30, MAX : 500,},\r\n        }\r\n    };\r\n    var encoded = [];\r\n    var param = configObj.Param;\r\n    var value = configObj.Value;\r\n    if(param == null || value == null){\r\n        return [];\r\n    }\r\n\r\n    var config = CONFIG_DEVICE.TYPES[param];\r\n    if(config == null) {\r\n        return [];\r\n    }\r\n    \r\n    if(value < config.MIN || value > config.MAX) {\r\n        return [];\r\n    }\r\n\r\n    if(config.CHANNEL != null)\r\n    {\r\n        encoded.push(config.CHANNEL);\r\n    }else\r\n    {\r\n        encoded.push(CONFIG_DEVICE.CHANNEL);\r\n    }\r\n    encoded.push(config.TYPE);\r\n    for(var i=1; i<=config.SIZE; i=i+1)\r\n    {\r\n        encoded.push( (value >> 8*(config.SIZE - i)) % 256 );\r\n    }\r\n\r\n    return encoded;\r\n}\r\n\r\nfunction encodePeriodicPackage(configObj)\r\n{\r\n    // Constants for device periodic package \r\n    var CONFIG_PERIODIC = {\r\n        CHANNEL : 0xFF,\r\n        TYPES : {\r\n            \"Interval\" : {TYPE : 0x14, SIZE : 1, MIN : 1, MAX : 255,},\r\n            \"Mode\" : {TYPE : 0x15, SIZE : 1, MIN : 0, MAX : 1,},\r\n            \"Status\" : {TYPE : 0x16, SIZE : 1, MIN : 0, MAX : 1,},\r\n            \"Measurement\" : {TYPE : 0x17, SIZE : 1, MIN : 0, MAX : 10,},\r\n        },\r\n        MEASUREMENTS : {\r\n            index : 0x00,\r\n            timestamp : 0x01,\r\n            dataloggerTimestamp : 0x03,\r\n            activeEnergyImportL123T1 : 0x04,\r\n            activeEnergyImportL123T2 : 0x05,\r\n            activeEnergyExportL123T1 : 0x06,\r\n            activeEnergyExportL123T2 : 0x07,\r\n            reactiveEnergyImportL123T1 : 0x08,\r\n            reactiveEnergyImportL123T2 : 0x09,\r\n            reactiveEnergyExportL123T1 : 0x0A,\r\n            reactiveEnergyExportL123T2 : 0x0B,\r\n            voltageL1N : 0x0C,\r\n            voltageL2N : 0x0D,\r\n            voltageL3N : 0x0E,\r\n            currentL123 : 0x0F,\r\n            currentL1 : 0x10,\r\n            currentL2 : 0x11,\r\n            currentL3 : 0x12,\r\n            activePowerL123 : 0x13,\r\n            activePowerL1 : 0x14,\r\n            activePowerL2 : 0x15,\r\n            activePowerL3 : 0x16,\r\n            reactivePowerL1 : 0x17,\r\n            reactivePowerL2 : 0x18,\r\n            reactivePowerL3 : 0x19,\r\n            apparentPowerL1 : 0x1A,\r\n            apparentPowerL2 : 0x1B,\r\n            apparentPowerL3 : 0x1C,\r\n            powerFactorL1 : 0x1D,\r\n            powerFactorL2 : 0x1E,\r\n            powerFactorL3 : 0x1F,\r\n            phaseAngleL1 : 0x20,\r\n            phaseAngleL2 : 0x21,\r\n            phaseAngleL3 : 0x22,\r\n            frequency : 0x23,\r\n            totalSystemActivePower : 0x24,\r\n            totalSystemReactivePower : 0x25,\r\n            totalSystemApparentPower : 0x26,\r\n            maximumL1CurrentDemand : 0x27,\r\n            maximumL2CurrentDemand : 0x28,\r\n            maximumL3CurrentDemand : 0x29,\r\n            averagePower : 0x2A,\r\n            midYearOfCertification : 0x2B,\r\n            manufacturedYear : 0xF0,\r\n            firmwareVersion : 0xF1,\r\n            hardwareVersion : 0xF2,\r\n        }\r\n    };\r\n\r\n    var encoded = [];\r\n    var config = {};\r\n    var value = -1;\r\n    if(configObj.Interval == null || configObj.Mode == null ||\r\n        configObj.Status == null || configObj.Measurement == null){\r\n        return [];\r\n    }\r\n    \r\n    // Encode Interval, Mode, Status\r\n    var fields = [\"Interval\", \"Mode\", \"Status\"];\r\n    foreach(field: fields)\r\n    {\r\n        config = CONFIG_PERIODIC.TYPES[field];\r\n        value = configObj[field];\r\n        if(value < config.MIN || value > config.MAX){\r\n            return [];\r\n        }\r\n        encoded.push(CONFIG_PERIODIC.CHANNEL);\r\n        encoded.push(config.TYPE);\r\n        encoded.push(value);\r\n    }\r\n    // Encode Measurement\r\n    config = CONFIG_PERIODIC.TYPES.Measurement;\r\n    if(configObj.Measurement.size < config.MIN || \r\n        configObj.Measurement.size > config.MAX){\r\n        return [];\r\n    }\r\n    encoded.push(CONFIG_PERIODIC.CHANNEL);\r\n    encoded.push(config.TYPE);\r\n    foreach(field : configObj.Measurement)\r\n    {\r\n        if(CONFIG_PERIODIC.MEASUREMENTS[field] == null){\r\n            return [];\r\n        }\r\n        encoded.push(CONFIG_PERIODIC.MEASUREMENTS[field]);\r\n    }\r\n\r\n    return encoded;\r\n}",
    "updateOnlyKeys": [
      "manufacturer"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}