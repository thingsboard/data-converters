{
  "name": "ChirpStack Uplink Converter for Yobiiq EM4301",
  "type": "UPLINK",
  "debugMode": true,
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": "// Decode an uplink message from a buffer\n// payload - array of bytes\n// metadata - key/value object\n\n/** Decoder **/\n\n// decode payload to string\nvar payloadStr = decodeToString(payload);\n\n// decode payload to JSON\n// var data = decodeToJson(payload);\n\nvar deviceName = 'Device A';\nvar deviceType = 'thermostat';\nvar customerName = 'Customer C';\nvar groupName = 'thermostat devices';\nvar manufacturer = 'Example corporation';\n// use assetName and assetType instead of deviceName and deviceType\n// to automatically create assets instead of devices.\n// var assetName = 'Asset A';\n// var assetType = 'building';\n\n// Result object with device/asset attributes/telemetry data\nvar result = {\n// Use deviceName and deviceType or assetName and assetType, but not both.\n   deviceName: deviceName,\n   deviceType: deviceType,\n// assetName: assetName,\n// assetType: assetType,\n// customerName: customerName,\n   groupName: groupName,\n   attributes: {\n       model: 'Model A',\n       serialNumber: 'SN111',\n       integrationName: metadata['integrationName'],\n       manufacturer: manufacturer\n   },\n   telemetry: {\n       temperature: 42,\n       humidity: 80,\n       rawData: payloadStr\n   }\n};\n\n/** Helper functions **/\n\nfunction decodeToString(payload) {\n   return String.fromCharCode.apply(String, payload);\n}\n\nfunction decodeToJson(payload) {\n   // covert payload to string.\n   var str = decodeToString(payload);\n\n   // parse string to JSON\n   var data = JSON.parse(str);\n   return data;\n}\n\nreturn result;",
    "tbelDecoder": "var data = decodeToJson(payload);\r\nvar deviceName = data.deviceInfo.deviceName;\r\nvar deviceType = 'Electricity Meter';\r\nvar groupName = 'Electricity Meters';\r\nvar customerName = data.deviceInfo.tags.customerName;\r\n\r\n// --- attributes and telemetry objects ---\r\nvar telemetryArray = [];\r\nvar attributes = {};\r\n\r\n// --- Timestamp parsing\r\nvar dateString = data.time;\r\nvar timestamp = -1;\r\nif (dateString != null) {\r\n  timestamp = new Date(dateString).getTime();\r\n  if (timestamp == -1) {\r\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\r\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\r\n      if (millisecondsEndIndex == -1) {\r\n          millisecondsEndIndex = dateString.lastIndexOf('Z');\r\n      }\r\n      if (millisecondsEndIndex == -1) {\r\n          millisecondsEndIndex = dateString.lastIndexOf('-');\r\n      }\r\n      if (millisecondsEndIndex == -1) {\r\n          if (dateString.length >= secondsSeparatorIndex + 3) {\r\n              dateString = dateString.substring(0, secondsSeparatorIndex + 3);\r\n          }\r\n      } else {\r\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\r\n              dateString.substring(millisecondsEndIndex, dateString.length);\r\n      }\r\n      timestamp = new Date(dateString).getTime();\r\n  }\r\n}\r\n// If we cannot parse timestamp - we will use the current timestamp\r\nif (timestamp == -1) {\r\n    timestamp = Date.now();\r\n}\r\n\r\nattributes.putAll( getVersionControl() );\r\nattributes.putAll(data.deviceInfo);\r\nattributes.remove('deviceName');\r\n\r\nif(data.fPort == null)\r\n{\r\n    // No uplink : end of decoder\r\n    var result = {\r\n        deviceName: deviceName,\r\n        deviceType: deviceType,\r\n        groupName: groupName,\r\n        attributes: attributes,\r\n        telemetry: telemetryArray\r\n    };\r\n    if(customerName != null){\r\n        result.customerName = customerName;\r\n    }    \r\n    return result;\r\n}\r\n\r\nvar telemetryData = {};\r\ntelemetryData.fPort = data.fPort;\r\ntelemetryData.confirmed = data.confirmed;\r\ntelemetryData.fCnt = data.fCnt;\r\ntelemetryData.dr = data.dr;\r\ntelemetryArray.push({ts:timestamp, values:telemetryData});\r\n\r\n// input uplink\r\nvar input = {\r\n    fPort: data.fPort,\r\n    bytes: hexStringToIntList(base64ToHex(data.data)),\r\n    variables: null,\r\n};\r\n\r\n// Decode uplink\r\nvar up = {\r\n    timestamp : timestamp,\r\n    fPort: input.fPort,\r\n    object: decodeUplink(input).data,\r\n    isDownlinkAnswer: false,\r\n    isBasicInfo: false,\r\n};\r\n\r\nif(up.fPort == 50)\r\n{\r\n    up.isDownlinkAnswer = true;\r\n    /* hardwareVersion indicates that is basic info so save them to attributes */\r\n    if(up.object.hardwareVersion != null)\r\n    {\r\n        up.isBasicInfo = true;\r\n    }\r\n} else if(up.fPort >= 1 && up.fPort <= 10)\r\n{\r\n    if(up.object.warning != null || up.object.info != null)\r\n    {\r\n        up.isDownlinkAnswer = true;\r\n    }\r\n}\r\n\r\nattributes.putAll( getAttributes(up) );\r\nvar telemetry = getTelemetry(up);\r\nif(telemetry != null){\r\n    telemetryArray.push(telemetry);\r\n}\r\n\r\nvar result = {\r\n    deviceName: deviceName,\r\n    deviceType: deviceType,\r\n    // assetName: assetName,\r\n    // assetType: assetType,\r\n    groupName: groupName,\r\n    attributes: attributes,\r\n    telemetry: telemetryArray\r\n};\r\nif(customerName != null)\r\n{\r\n    result.customerName = customerName;\r\n}\r\n\r\nreturn result;\r\n\r\n\r\n\r\n/**\r\n * @brief converts device parameters into attributes\r\n * \r\n * @param up uplink object \r\n * \r\n * @return device attributes\r\n */\r\nfunction getAttributes(up)\r\n{\r\n\tvar params = {};\r\n    params.latestFPort = up.fPort;\r\n\r\n\tif(up.isDownlinkAnswer == false)\r\n\t{\r\n\t\treturn params;\r\n\t}\r\n\r\n\tif(up.object.warning != null )\r\n\t{\r\n\t\tparams.latestDownlinkStatus = up.timestamp + \"-FAILURE\";\r\n\t\treturn params;\r\n\t}\r\n\r\n\tif(up.object.info != null)\r\n\t{\r\n\t\tparams.latestDownlinkStatus = up.timestamp + \"-SUCCESS\";\r\n\t\treturn params;\r\n\t}\r\n    \r\n    var additionalAttributes = {};\r\n    foreach(element: up.object.entrySet())\r\n    {\r\n        if(up.isBasicInfo){\r\n            if(element.value instanceof java.util.Map && element.value.data != null){\r\n                additionalAttributes[element.key] = element.value.data;\r\n            }else{\r\n                additionalAttributes[element.key] = element.value;\r\n            }\r\n        }else{\r\n            var capitalizeKey = element.key.substring(0, 1).toUpperCase() + element.key.substring(1);\r\n            if(element.value instanceof java.util.Map && element.value.data != null){\r\n                additionalAttributes[\"latestSetting\" + capitalizeKey] = element.value.data;\r\n            }else{\r\n                additionalAttributes[\"latestSetting\" + capitalizeKey] = element.value;\r\n            }\r\n        }\r\n    }\r\n\r\n    if(up.isBasicInfo)\r\n    {\r\n        params.putAll(additionalAttributes);\r\n    }else {\r\n        params.latestDownlinkStatus = up.timestamp + \"-SUCCESS\";\r\n        params.latestIncomingSettings = additionalAttributes;\r\n    }\r\n\r\n\treturn params;\r\n}\r\n\r\n/**\r\n * @brief converts device measurements into telemetry\r\n * \r\n * @param up uplink object \r\n * \r\n * @return device telemetry\r\n */\r\nfunction getTelemetry(up)\r\n{\r\n\tif(up.isBasicInfo || up.isDownlinkAnswer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\r\n    var ts = up.timestamp;\r\n    if(up.object.dataloggerTimestamp != null)\r\n    {\r\n        // use dataloggerTimestamp when it exists\r\n        ts = up.object.dataloggerTimestamp * 1000;   // dataloggerTimestamp is in seconds\r\n        up.object.remove(\"dataloggerTimestamp\");\r\n    }\r\n\r\n    var values = {};\r\n    foreach(element: up.object.entrySet())\r\n    {\r\n        if(element.value instanceof java.util.Map && element.value.data != null)\r\n        {\r\n            values[element.key] = element.value.data;\r\n        }else{\r\n            values[element.key] = element.value;\r\n        }\r\n    }\r\n    \r\n    return {ts: ts, values: values};\r\n}\r\n\r\n\r\n/********************************** Yobiiq Decoder ******************************/\r\n\r\nfunction decodeBasicInformation(bytes)\r\n{\r\n    // Configuration constants for device basic info and current settings\r\n    var CONFIG_INFO = {\r\n        FPORT     : 50,\r\n        CHANNEL  : 0xFF,\r\n        TYPES    : {\r\n            \"0x09\" : {SIZE : 2, NAME : \"hardwareVersion\", DIGIT: false},\r\n            \"0x0A\" : {SIZE : 2, NAME : \"firmwareVersion\", DIGIT: false},\r\n            \"0x16\" : {SIZE : 4, NAME : \"deviceSerialNumber\"},\r\n            \"0x0F\" : {SIZE : 1, NAME : \"deviceClass\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"Class A\",\r\n                    \"0x01\" : \"Class B\",\r\n                    \"0x02\" : \"Class C\",\r\n                },\r\n            },\r\n            \"0x0B\" : {SIZE : 1, NAME : \"powerEvent\",\r\n                VALUES     : {\r\n                    \"0x00\" : \"AC Power Off\",\r\n                    \"0x01\" : \"AC Power On\",\r\n                },\r\n            },\r\n            \"0x1E\" : {SIZE : 2, NAME : \"primaryCurrentTransformerRatio\",},\r\n            \"0x1F\" : {SIZE : 1, NAME : \"secondaryCurrentTransformerRatio\",},\r\n            \"0x20\" : {SIZE : 4, NAME : \"primaryVoltageTransformerRatio\",},\r\n            \"0x21\" : {SIZE : 2, NAME : \"secondaryVoltageTransformerRatio\",},\r\n            \"0x28\" : {SIZE : 0, NAME : \"deviceModel\",},\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n    };\r\n\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = 0;\r\n    var type = \"\";\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_INFO.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_INFO.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    \r\n    while(index < LENGTH)\r\n    {\r\n        channel = bytes[index];\r\n        index = index + 1;\r\n        // No channel checking\r\n        // Type of basic information\r\n        type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;\r\n        var info = CONFIG_INFO.TYPES[type];\r\n        if(info == null)\r\n        {\r\n            decoded[CONFIG_INFO.ERROR_NAME] = \"can't decode type \"+ type;\r\n            return decoded;\r\n        }\r\n        size = info.SIZE;\r\n        // Decoding\r\n        var value = 0;\r\n        if(size != 0)\r\n        {\r\n            if(info.DIGIT != null)\r\n            {\r\n                if(info.DIGIT == false)\r\n                {\r\n                    // Decode into \"V\" + DIGIT STRING + \".\" DIGIT STRING format\r\n                    value = getDigitStringArrayNoFormat(bytes, index, size);\r\n                    value = \"V\" + value[0] + \".\" + value[1];\r\n                }else\r\n                {\r\n                    // Decode into DIGIT STRING format\r\n                    value = getDigitStringArrayEvenFormat(bytes, index, size);\r\n                    value = value.toString();\r\n                }\r\n            }\r\n            else if(info.VALUES != null)\r\n            {\r\n                // Decode into STRING (VALUES specified in CONFIG_INFO)\r\n                value = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n                value = info.VALUES[value];\r\n            }else\r\n            {\r\n                // Decode into DECIMAL format\r\n                value = getValueFromBytesBigEndianFormat(bytes, index, size);\r\n            }\r\n            if(info.RESOLUTION != null)\r\n            {\r\n                value = value * info.RESOLUTION;\r\n                value = toFixed(value, 2);\r\n            }\r\n            decoded[info.NAME] = value;\r\n            index = index + size;\r\n        }else\r\n        {\r\n            // Device Model\r\n            size = getSizeBasedOnChannel(bytes, index, channel);\r\n            decoded[info.NAME] = getStringFromBytesBigEndianFormat(bytes, index, size);\r\n            index = index + size;\r\n        }\r\n    }\r\n    return decoded;\r\n}\r\n\r\nfunction decodeDeviceData(bytes)\r\n{\r\n    // Configuration constants for measurement registers\r\n    var CONFIG_MEASUREMENT = {\r\n        FPORT_MIN : 1,\r\n        FPORT_MAX : 10,\r\n        TYPES : {\r\n            \"0x00\" : {SIZE : 4, NAME : \"index\",},\r\n            \"0x01\" : {SIZE : 4, NAME : \"timestamp\",},\r\n            \"0x03\" : {SIZE : 4, NAME : \"dataloggerTimestamp\",},\r\n            \"0x04\" : {SIZE : 4, NAME : \"activeEnergyImportL123T1\", UNIT : \"Wh\",},\r\n            \"0x05\" : {SIZE : 4, NAME : \"activeEnergyImportL123T2\", UNIT : \"Wh\",},\r\n            \"0x06\" : {SIZE : 4, NAME : \"activeEnergyExportL123T1\", UNIT : \"Wh\",},\r\n            \"0x07\" : {SIZE : 4, NAME : \"activeEnergyExportL123T2\", UNIT : \"Wh\",},\r\n            \"0x08\" : {SIZE : 4, NAME : \"reactiveEnergyImportL123T1\", UNIT : \"varh\",},\r\n            \"0x09\" : {SIZE : 4, NAME : \"reactiveEnergyImportL123T2\", UNIT : \"varh\",},\r\n            \"0x0A\" : {SIZE : 4, NAME : \"reactiveEnergyExportL123T1\", UNIT : \"varh\",},\r\n            \"0x0B\" : {SIZE : 4, NAME : \"reactiveEnergyExportL123T2\", UNIT : \"varh\",},\r\n            \"0x0C\" : {SIZE : 4, NAME : \"voltageL1N\", UNIT : \"V\", RESOLUTION : 0.1, SIGNED : true,},\r\n            \"0x0D\" : {SIZE : 4, NAME : \"voltageL2N\", UNIT : \"V\", RESOLUTION : 0.1, SIGNED : true,},\r\n            \"0x0E\" : {SIZE : 4, NAME : \"voltageL3N\", UNIT : \"V\", RESOLUTION : 0.1, SIGNED : true,},\r\n            \"0x0F\" : {SIZE : 4, NAME : \"currentL123\", UNIT : \"mA\", SIGNED : true,},\r\n            \"0x10\" : {SIZE : 4, NAME : \"currentL1\", UNIT : \"mA\", SIGNED : true,},\r\n            \"0x11\" : {SIZE : 4, NAME : \"currentL2\", UNIT : \"mA\", SIGNED : true,},\r\n            \"0x12\" : {SIZE : 4, NAME : \"currentL3\", UNIT : \"mA\", SIGNED : true,},\r\n            \"0x13\" : {SIZE : 4, NAME : \"activePowerL123\", UNIT : \"W\", SIGNED : true,},\r\n            \"0x14\" : {SIZE : 4, NAME : \"activePowerL1\", UNIT : \"W\", SIGNED : true,},\r\n            \"0x15\" : {SIZE : 4, NAME : \"activePowerL2\", UNIT : \"W\", SIGNED : true,},\r\n            \"0x16\" : {SIZE : 4, NAME : \"activePowerL3\", UNIT : \"W\", SIGNED : true,},\r\n            \"0x17\" : {SIZE : 4, NAME : \"reactivePowerL1\", UNIT : \"kvar\", RESOLUTION : 0.001, SIGNED : true,},\r\n            \"0x18\" : {SIZE : 4, NAME : \"reactivePowerL2\", UNIT : \"kvar\", RESOLUTION : 0.001, SIGNED : true,},\r\n            \"0x19\" : {SIZE : 4, NAME : \"reactivePowerL3\", UNIT : \"kvar\", RESOLUTION : 0.001, SIGNED : true,},\r\n            \"0x1A\" : {SIZE : 4, NAME : \"apparentPowerL1\", UNIT : \"kVA\", RESOLUTION : 0.001, SIGNED : true,},\r\n            \"0x1B\" : {SIZE : 4, NAME : \"apparentPowerL2\", UNIT : \"kVA\", RESOLUTION : 0.001, SIGNED : true,},\r\n            \"0x1C\" : {SIZE : 4, NAME : \"apparentPowerL3\", UNIT : \"kVA\", RESOLUTION : 0.001, SIGNED : true,},\r\n            \"0x1D\" : {SIZE : 1, NAME : \"powerFactorL1\", RESOLUTION : 0.01, SIGNED : true,},\r\n            \"0x1E\" : {SIZE : 1, NAME : \"powerFactorL2\", RESOLUTION : 0.01, SIGNED : true,},\r\n            \"0x1F\" : {SIZE : 1, NAME : \"powerFactorL3\", RESOLUTION : 0.01, SIGNED : true,},\r\n            \"0x20\" : {SIZE : 2, NAME : \"phaseAngleL1\", UNIT : \"degree\", RESOLUTION : 0.01, SIGNED : true,},\r\n            \"0x21\" : {SIZE : 2, NAME : \"phaseAngleL2\", UNIT : \"degree\", RESOLUTION : 0.01, SIGNED : true,},\r\n            \"0x22\" : {SIZE : 2, NAME : \"phaseAngleL3\", UNIT : \"degree\", RESOLUTION : 0.01, SIGNED : true,},\r\n            \"0x23\" : {SIZE : 2, NAME : \"frequency\", UNIT : \"Hz\", RESOLUTION : 0.01, SIGNED : true,},\r\n            \"0x24\" : {SIZE : 4, NAME : \"totalSystemActivePower\", UNIT : \"kW\",},\r\n            \"0x25\" : {SIZE : 4, NAME : \"totalSystemReactivePower\", UNIT : \"kvar\", RESOLUTION : 0.001,},\r\n            \"0x26\" : {SIZE : 4, NAME : \"totalSystemApparentPower\", UNIT : \"kVA\", RESOLUTION : 0.001,},\r\n            \"0x27\" : {SIZE : 4, NAME : \"maximumL1CurrentDemand\", UNIT : \"mA\", SIGNED : true,},\r\n            \"0x28\" : {SIZE : 4, NAME : \"maximumL2CurrentDemand\", UNIT : \"mA\", SIGNED : true,},\r\n            \"0x29\" : {SIZE : 4, NAME : \"maximumL3CurrentDemand\", UNIT : \"mA\", SIGNED : true,},\r\n            \"0x2A\" : {SIZE : 4, NAME : \"averagePower\", UNIT : \"W\", SIGNED : true,},\r\n            \"0x2B\" : {SIZE : 4, NAME : \"midYearOfCertification\",},\r\n            \"0xF0\" : {SIZE : 2, NAME : \"manufacturedYear\", DIGIT: true,},\r\n            \"0xF1\" : {SIZE : 2, NAME : \"firmwareVersion\", DIGIT: false,},\r\n            \"0xF2\" : {SIZE : 2, NAME : \"hardwareVersion\", DIGIT: false,},\r\n        },\r\n        WARNING_NAME   : \"warning\",\r\n        ERROR_NAME     : \"error\",\r\n        INFO_NAME      : \"info\"\r\n    };\r\n\r\n    var LENGTH = bytes.length;\r\n    var decoded = {};\r\n    var index = 0;\r\n    var channel = 0;\r\n    var type = \"\";\r\n    var size = 0;\r\n    if(LENGTH == 1)\r\n    {\r\n        if(bytes[0] == 0)\r\n        {\r\n            decoded[CONFIG_MEASUREMENT.INFO_NAME] = \"Downlink command succeeded\";\r\n\r\n        } else if(bytes[0] == 1)\r\n        {\r\n            decoded[CONFIG_MEASUREMENT.WARNING_NAME] = \"Downlink command failed\";\r\n        }\r\n        return decoded;\r\n    }\r\n    while(index < LENGTH)\r\n    {\r\n        channel = bytes[index];\r\n        index = index + 1;\r\n        // Type of device measurement\r\n        type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n        index = index + 1;          \r\n        // channel checking\r\n        if(channel == 11 && type == \"0x0A\")\r\n        {\r\n            // Modbus error code decoding\r\n            decoded.modbusErrorCode = bytes[index];\r\n            index = index + 1;\r\n            // continue; // next channel\r\n            if(index >= LENGTH)\r\n            {\r\n                return decoded; // end\r\n            }\r\n            channel = bytes[index];\r\n            index = index + 1;\r\n            // Type of device measurement\r\n            type = \"0x\" + byteToEvenHex(bytes[index]).toUpperCase();\r\n            index = index + 1; \r\n        }\r\n        var measurement = CONFIG_MEASUREMENT.TYPES[type];\r\n        if(measurement == null)\r\n        {\r\n            decoded[CONFIG_MEASUREMENT.ERROR_NAME] = \"can't decode type \"+ type;\r\n            return decoded;\r\n        }\r\n        size = measurement.SIZE;\r\n        // Decoding\r\n        var value = 0;\r\n        if(measurement.DIGIT != null)\r\n        {\r\n            if(measurement.DIGIT == false)\r\n            {\r\n                // Decode into \"V\" + DIGIT STRING + \".\" DIGIT STRING format\r\n                value = getDigitStringArrayNoFormat(bytes, index, size);\r\n                value = \"V\" + value[0] + \".\" + value[1];\r\n            }else\r\n            {\r\n                // Decode into DIGIT NUMBER format\r\n                value = getDigitStringArrayEvenFormat(bytes, index, size);\r\n                value = parseInt(value.join(\"\"));\r\n            }\r\n        }else\r\n        {\r\n            // Decode into DECIMAL format\r\n            value = getValueFromBytesBigEndianFormat(bytes, index, size);\r\n        }\r\n        if(measurement.SIGNED != null)\r\n        {\r\n            value = parseBytesToAnyInt(bytes, index, size, true);\r\n        }\r\n        if(measurement.RESOLUTION != null)\r\n        {\r\n            value = value * measurement.RESOLUTION;\r\n            value = toFixed(value, 2);\r\n        }\r\n        decoded[measurement.NAME] = value;\r\n        index = index + size;\r\n    }\r\n    return decoded;\r\n}\r\n\r\n\r\nfunction getSizeBasedOnChannel(bytes, index, channel)\r\n{\r\n    var size = 0;\r\n    while(index + size < bytes.length && bytes[index + size] != channel)\r\n    {\r\n        size = size + 1;\r\n    }\r\n    return size;\r\n}\r\n\r\nfunction getStringFromBytesBigEndianFormat(bytes, index, size)\r\n{\r\n    var byteArray = [];\r\n    for(var i=0; i<size; i=i+1)\r\n    {\r\n        byteArray.push(bytes[index+i]);\r\n    }\r\n    return bytesToString(byteArray);\r\n}\r\n\r\nfunction getStringFromBytesLittleEndianFormat(bytes, index, size)\r\n{\r\n    var byteArray = [];\r\n    for(var i=(size - 1); i>=0; i=i-1)\r\n    {\r\n        byteArray.push(bytes[index+i]);\r\n    }\r\n    return bytesToString(byteArray);\r\n}\r\n\r\nfunction getValueFromBytesBigEndianFormat(bytes, index, size)\r\n{\r\n    if(size >= 4){\r\n        return parseBytesToLong(bytes, index, size, true);\r\n    }\r\n    return parseBytesToInt(bytes, index, size, true);\r\n}\r\n\r\nfunction getValueFromBytesLittleEndianFormat(bytes, index, size)\r\n{\r\n    if(size >= 4){\r\n        return parseBytesToLong(bytes, index, size, false);\r\n    }\r\n    return parseBytesToInt(bytes, index, size, false);\r\n}\r\n\r\nfunction getDigitStringArrayNoFormat(bytes, index, size)\r\n{\r\n    var hexString = [];\r\n    for(var i=0; i<size; i=i+1)\r\n    {\r\n        hexString.push(Integer.toString(bytes[index+i], 16));\r\n    }\r\n    return hexString;\r\n}\r\n\r\nfunction getDigitStringArrayEvenFormat(bytes, index, size)\r\n{\r\n    var hexString = [];\r\n    for(var i=0; i<size; i=i+1)\r\n    {\r\n        hexString.push(byteToEvenHex(bytes[index+i]));\r\n    }\r\n    return hexString;\r\n}\r\n\r\nfunction toEvenHEX(hex)\r\n{\r\n    if(hex.length == 1)\r\n    {\r\n        return \"0\"+hex;\r\n    }\r\n    return hex;\r\n}\r\n\r\n\r\nfunction byteToEvenHex(val)\r\n{\r\n    return toEvenHEX(Integer.toString(val, 16));\r\n}\r\n\r\nfunction hexStringToIntList(hexString)\r\n{\r\n    var bytes = [];\r\n    var hexByte = \"\";\r\n    for(var i=0; i<hexString.length; i=i+2)\r\n    {\r\n        hexByte = hexString[i] + hexString[i+1];\r\n        bytes.push(parseHexToInt(hexByte));\r\n    }\r\n    return bytes;\r\n}\r\n\r\n/**\r\n * @brief This function supports conversion to positive or negative value of type INT8, INT16, INT24, INT32, etc.. \r\n */\r\nfunction parseBytesToAnyInt(bytes, offset, length, bigEndian)\r\n{\r\n    var byteArray = [];\r\n    if(length > 4)\r\n    {\r\n        return parseBytesToLong(bytes, offset, length, bigEndian);\r\n    }\r\n    var value = parseBytesToInt(bytes, offset, length, bigEndian);\r\n    var isValueNegative = false;\r\n    var CONFIG_TYPE = {\r\n        INT8_MAX : 127,\r\n        INT16_MAX : 32767,\r\n        INT24_MAX : 8388607,\r\n    };\r\n    \r\n    if(length == 1){\r\n        if(value > CONFIG_TYPE.INT8_MAX){\r\n            isValueNegative = true;\r\n        }\r\n    }else if(length == 2){\r\n        if(value > CONFIG_TYPE.INT16_MAX){\r\n            isValueNegative = true;\r\n        }\r\n    }else if(length == 3){\r\n        if(value > CONFIG_TYPE.INT24_MAX){\r\n            isValueNegative = true;\r\n        }\r\n    }\r\n\r\n    if(isValueNegative == false)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    for(var i=0; i<4; i=i+1){\r\n        if(i < (4 - length)){\r\n            byteArray.push(255);\r\n        }else{\r\n            var index = i - (4 - length);\r\n            if(bigEndian){\r\n                byteArray.push(bytes[offset + index]);\r\n            }else{\r\n                byteArray.push(bytes[offset + (length - 1) - index]);\r\n            }\r\n        }\r\n    }\r\n    return parseBytesToInt(byteArray, 0, 4, bigEndian);\r\n}\r\n\r\n/************************************************************************************************************/\r\n\r\n// Decode decodes an array of bytes into an object. (ChirpStack v3)\r\n//  - fPort contains the LoRaWAN fPort number\r\n//  - bytes is an array of bytes, e.g. [225, 230, 255, 0]\r\n//  - variables contains the device variables e.g. {\"calibration\": \"3.5\"} (both the key / value are of type string)\r\n// The function must return an object, e.g. {\"temperature\": 22.5}\r\nfunction Decode(fPort, bytes, variables) \r\n{\r\n    var decoded = {};\r\n    if(fPort == 0)\r\n    {\r\n        decoded = {mac: \"MAC command received\", fPort: fPort};\r\n    } else if(fPort == 50)\r\n    {\r\n        decoded = decodeBasicInformation(bytes);\r\n    }else if(fPort >= 1 && fPort <= 10)\r\n    {\r\n        decoded = decodeDeviceData(bytes);\r\n    }else\r\n    {\r\n        decoded = {error: \"Incorrect fPort\", fPort : fPort};\r\n    }\r\n    return decoded;\r\n}\r\n\r\n// Decode uplink function. (ChirpStack v4 , TTN)\r\n//\r\n// Input is an object with the following fields:\r\n// - bytes = Byte array containing the uplink payload, e.g. [255, 230, 255, 0]\r\n// - fPort = Uplink fPort.\r\n// - variables = Object containing the configured device variables.\r\n//\r\n// Output must be an object with the following fields:\r\n// - data = Object representing the decoded payload.\r\nfunction decodeUplink(input) {\r\n    return {\r\n        data: Decode(input.fPort, input.bytes, input.variables)\r\n    };\r\n}\r\n\r\nfunction getVersionControl()\r\n{\r\n    // Version Control\r\n    var VERSION_CONTROL = {\r\n        CODEC : {VERSION: \"1.0.0\", NAME: \"codecVersion\"},\r\n        DEVICE: {MODEL : \"EM4301\", NAME: \"genericModel\"},\r\n        PRODUCT: {CODE : \"P1002011\", NAME: \"productCode\"},\r\n        MANUFACTURER: {COMPANY : \"YOBIIQ B.V.\", NAME: \"manufacturer\"},\r\n    };\r\n    var decoded = {};\r\n    decoded[VERSION_CONTROL.CODEC.NAME] = VERSION_CONTROL.CODEC.VERSION;\r\n    decoded[VERSION_CONTROL.DEVICE.NAME] = VERSION_CONTROL.DEVICE.MODEL;\r\n    decoded[VERSION_CONTROL.PRODUCT.NAME] = VERSION_CONTROL.PRODUCT.CODE;\r\n    decoded[VERSION_CONTROL.MANUFACTURER.NAME] = VERSION_CONTROL.MANUFACTURER.COMPANY;\r\n    return decoded;\r\n}",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "manufacturer"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false
}