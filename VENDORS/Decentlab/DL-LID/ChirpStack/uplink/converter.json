{
  "name": "ChirpStack Uplink Decoder for Decentlab DL-LID",
  "type": "UPLINK",
  "debugMode": true,
  "edgeTemplate": false,
  "configuration": {
    "scriptLang": "JS",
    "updateOnlyKeys": [
      "lora_frame_counter",
      "lora_frame_port",
      "lora_frequency",
      "lora_spreading_factor",
      "lora_rssi",
      "lora_dev_eui",
      "lora_snr"
    ],
    "decoder": "const message = decodeToJson(payload);\nconst values = Object.assign(\n  decodeDevicePayload(base64ToBytes(message.data)),\n  extractNetworkTelemetry(message)\n);\n\nreturn {\n  deviceName: String(values.device_id),\n  deviceType: 'DL-LID',\n  attributes: {\n    lora_dev_eui: values.lora_dev_eui,\n    protocol_version: values.protocol_version,\n  },\n  telemetry: [{\n    ts: message.time,\n    values: keepTelemetry(values)\n  }]\n};\n\nfunction decodeDevicePayload(payload) {\n  /* https://www.decentlab.com/products/laser-distance-level-sensor-for-lorawan */\n  const decentlab_decoder = {\n    PROTOCOL_VERSION: 2,\n    SENSORS: [\n      {length: 11,\n       values: [{name: 'distance_average',\n                 displayName: 'Distance: average',\n                 convert: function (x) { return x[0]; },\n                 unit: 'mm'},\n                {name: 'distance_minimum',\n                 displayName: 'Distance: minimum',\n                 convert: function (x) { return x[1]; },\n                 unit: 'mm'},\n                {name: 'distance_maximum',\n                 displayName: 'Distance: maximum',\n                 convert: function (x) { return x[2]; },\n                 unit: 'mm'},\n                {name: 'distance_median',\n                 displayName: 'Distance: median',\n                 convert: function (x) { return x[3]; },\n                 unit: 'mm'},\n                {name: 'distance_10th_percentile',\n                 displayName: 'Distance: 10th percentile',\n                 convert: function (x) { return x[4]; },\n                 unit: 'mm'},\n                {name: 'distance_25th_percentile',\n                 displayName: 'Distance: 25th percentile',\n                 convert: function (x) { return x[5]; },\n                 unit: 'mm'},\n                {name: 'distance_75th_percentile',\n                 displayName: 'Distance: 75th percentile',\n                 convert: function (x) { return x[6]; },\n                 unit: 'mm'},\n                {name: 'distance_90th_percentile',\n                 displayName: 'Distance: 90th percentile',\n                 convert: function (x) { return x[7]; },\n                 unit: 'mm'},\n                {name: 'distance_most_frequent_value',\n                 displayName: 'Distance: most frequent value',\n                 convert: function (x) { return x[8]; },\n                 unit: 'mm'},\n                {name: 'number_of_samples',\n                 displayName: 'Number of samples',\n                 convert: function (x) { return x[9]; }},\n                {name: 'total_acquisition_time',\n                 displayName: 'Total acquisition time',\n                 convert: function (x) { return x[10] / 1.024; },\n                 unit: 'ms'}]},\n      {length: 1,\n       values: [{name: 'battery_voltage',\n                 displayName: 'Battery voltage',\n                 convert: function (x) { return x[0] / 1000; },\n                 unit: 'V'}]}\n    ],\n    read_int: function (bytes, pos) {\n      return (bytes[pos] << 8) + bytes[pos + 1];\n    },\n    decode: function (msg) {\n      var bytes = msg;\n      var i, j;\n      if (typeof msg === 'string') {\n        bytes = [];\n        for (i = 0; i < msg.length; i += 2) {\n          bytes.push(parseInt(msg.substring(i, i + 2), 16));\n        }\n      }\n      var version = bytes[0];\n      if (version != this.PROTOCOL_VERSION) {\n        return {error: \"protocol version \" + version + \" doesn't match v2\"};\n      }\n      var deviceId = this.read_int(bytes, 1);\n      var flags = this.read_int(bytes, 3);\n      var result = {'protocol_version': version, 'device_id': deviceId};\n      // decode payload\n      var pos = 5;\n      for (i = 0; i < this.SENSORS.length; i++, flags >>= 1) {\n        if ((flags & 1) !== 1)\n          continue;\n        var sensor = this.SENSORS[i];\n        var x = [];\n        // convert data to 16-bit integer array\n        for (j = 0; j < sensor.length; j++) {\n          x.push(this.read_int(bytes, pos));\n          pos += 2;\n        }\n        // decode sensor values\n        for (j = 0; j < sensor.values.length; j++) {\n          var value = sensor.values[j];\n          if ('convert' in value) {\n            result[value.name] = {displayName: value.displayName,\n                                  value: value.convert.bind(this)(x)};\n            if ('unit' in value)\n              result[value.name]['unit'] = value.unit;\n          }\n        }\n      }\n      return result;\n    }\n  };\n\n  const decoded = decentlab_decoder.decode(payload);\n  const result = {};\n  for (var k in decoded) {\n    if (typeof decoded[k] === \"object\") {\n      result[k] = decoded[k].value;\n    } else if (typeof decoded[k] === \"number\") {\n      result[k] = decoded[k];\n    }\n  }\n  return result;\n}\n\nfunction extractNetworkTelemetry(payload) {\n  const result = {\n      lora_frame_counter: message.fCnt,\n      lora_frame_port: message.fPort,\n      lora_frequency: message.txInfo.frequency,\n      lora_spreading_factor:\n          message?.txInfo?.modulation?.lora?.spreadingFactor ||\n          message.txInfo.loRaModulationInfo.spreadingFactor,\n      lora_dev_eui: (\n          message?.deviceInfo?.devEui ||\n          base64ToBytes(message.devEUI).reduce(\n              (a, x) => a + (\"0\" + x.toString(16)).slice(-2),\n              \"\",\n          )\n      ).toUpperCase(),\n  };\n  const gwi = message.rxInfo\n    .map((x) => ({ lora_rssi: x.rssi, lora_snr: x.snr || x.loRaSNR }))\n    .reduce((a, x) => (x.lora_rssi > a.lora_rssi ? x : a), {\n      lora_rssi: -Number.MAX_VALUE,\n    });\n  return Object.assign(result, gwi);\n}\n\n// Helper functions\n\nfunction decodeToJson(payload) {\n  const s = String.fromCharCode.apply(String, payload);\n  return JSON.parse(s);\n}\n\nfunction parseDateToTimestamp(dateString) {\n  var timestamp = -1;\n  if (dateString != null) {\n    timestamp = new Date(dateString).getTime();\n    if (timestamp == -1) {\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('Z');\n      }\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('-');\n      }\n      if (millisecondsEndIndex == -1) {\n        if (dateString.length >= secondsSeparatorIndex + 3) {\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n        }\n      } else {\n        dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n          dateString.substring(millisecondsEndIndex, dateString.length);\n      }\n      timestamp = new Date(dateString).getTime();\n    }\n  }\n  // If we cannot parse timestamp - we will use the current timestamp\n  if (timestamp == -1) {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n\nfunction base64ToBytes(base64String) {\n  if (typeof base64String === 'string') {\n    return Uint8Array.from(atob(base64String), c => c.charCodeAt(0));\n  }\n  return [];\n}\n\nfunction keepTelemetry(telemetry) {\n  const unwanted = ['protocol_version', 'device_id', 'lora_dev_eui'];\n  return Object.fromEntries(\n    Object.entries(telemetry).filter(\n      (x) => !unwanted.includes(x[0])\n    )\n  );\n}"
  }
}