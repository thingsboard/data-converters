{
  "name": "ThingPark Uplink Decoder for Decentlab DL-ATM41",
  "type": "UPLINK",
  "debugMode": true,
  "edgeTemplate": false,
  "configuration": {
    "scriptLang": "JS",
    "updateOnlyKeys": [
      "lora_frame_counter",
      "lora_frame_port",
      "lora_frequency",
      "lora_spreading_factor",
      "lora_rssi",
      "lora_dev_eui",
      "lora_snr"
    ],
    "decoder": "// WARNING: This script is designed to work with a remote JS executor. Compatibility with a local JS evaluator is not guaranteed and may require rewriting.\n\nconst message = decodeToJson(payload);\nconst values = Object.assign(\n  decodeDevicePayload(message.DevEUI_uplink.payload_hex),\n  extractNetworkTelemetry(message)\n);\n\nreturn {\n  deviceName: String(values.device_id),\n  deviceType: 'DL-ATM41',\n  attributes: {\n    lora_dev_eui: values.lora_dev_eui,\n    protocol_version: values.protocol_version,\n  },\n  telemetry: [{\n    ts: parseDateToTimestamp(message.DevEUI_uplink.Time),\n    values: keepTelemetry(values)\n  }]\n};\n\nfunction decodeDevicePayload(payload) {\n  /* https://www.decentlab.com/products/eleven-parameter-weather-station-for-lorawan */\n  const decentlab_decoder = {\n    PROTOCOL_VERSION: 2,\n    SENSORS: [\n      {length: 17,\n       values: [{name: 'solar_radiation',\n                 displayName: 'Solar radiation',\n                 convert: function (x) { return x[0] - 32768; },\n                 unit: 'W⋅m⁻²'},\n                {name: 'precipitation',\n                 displayName: 'Precipitation',\n                 convert: function (x) { return (x[1] - 32768) / 1000; },\n                 unit: 'mm'},\n                {name: 'lightning_strike_count',\n                 displayName: 'Lightning strike count',\n                 convert: function (x) { return x[2] - 32768; }},\n                {name: 'lightning_average_distance',\n                 displayName: 'Lightning average distance',\n                 convert: function (x) { return x[3] - 32768; },\n                 unit: 'km'},\n                {name: 'wind_speed',\n                 displayName: 'Wind speed',\n                 convert: function (x) { return (x[4] - 32768) / 100; },\n                 unit: 'm⋅s⁻¹'},\n                {name: 'wind_direction',\n                 displayName: 'Wind direction',\n                 convert: function (x) { return (x[5] - 32768) / 10; },\n                 unit: '°'},\n                {name: 'maximum_wind_speed',\n                 displayName: 'Maximum wind speed',\n                 convert: function (x) { return (x[6] - 32768) / 100; },\n                 unit: 'm⋅s⁻¹'},\n                {name: 'air_temperature',\n                 displayName: 'Air temperature',\n                 convert: function (x) { return (x[7] - 32768) / 10; },\n                 unit: '°C'},\n                {name: 'vapor_pressure',\n                 displayName: 'Vapor pressure',\n                 convert: function (x) { return (x[8] - 32768) / 100; },\n                 unit: 'kPa'},\n                {name: 'atmospheric_pressure',\n                 displayName: 'Atmospheric pressure',\n                 convert: function (x) { return (x[9] - 32768) / 100; },\n                 unit: 'kPa'},\n                {name: 'relative_humidity',\n                 displayName: 'Relative humidity',\n                 convert: function (x) { return (x[10] - 32768) / 10; },\n                 unit: '%'},\n                {name: 'sensor_temperature_internal',\n                 displayName: 'Sensor temperature (internal)',\n                 convert: function (x) { return (x[11] - 32768) / 10; },\n                 unit: '°C'},\n                {name: 'x_orientation_angle',\n                 displayName: 'X orientation angle',\n                 convert: function (x) { return (x[12] - 32768) / 10; },\n                 unit: '°'},\n                {name: 'y_orientation_angle',\n                 displayName: 'Y orientation angle',\n                 convert: function (x) { return (x[13] - 32768) / 10; },\n                 unit: '°'},\n                {name: 'compass_heading',\n                 displayName: 'Compass heading',\n                 convert: function (x) { return x[14] - 32768; },\n                 unit: '°'},\n                {name: 'north_wind_speed',\n                 displayName: 'North wind speed',\n                 convert: function (x) { return (x[15] - 32768) / 100; },\n                 unit: 'm⋅s⁻¹'},\n                {name: 'east_wind_speed',\n                 displayName: 'East wind speed',\n                 convert: function (x) { return (x[16] - 32768) / 100; },\n                 unit: 'm⋅s⁻¹'}]},\n      {length: 1,\n       values: [{name: 'battery_voltage',\n                 displayName: 'Battery voltage',\n                 convert: function (x) { return x[0] / 1000; },\n                 unit: 'V'}]}\n    ],\n    read_int: function (bytes, pos) {\n      return (bytes[pos] << 8) + bytes[pos + 1];\n    },\n    decode: function (msg) {\n      var bytes = msg;\n      var i, j;\n      if (typeof msg === 'string') {\n        bytes = [];\n        for (i = 0; i < msg.length; i += 2) {\n          bytes.push(parseInt(msg.substring(i, i + 2), 16));\n        }\n      }\n      var version = bytes[0];\n      if (version != this.PROTOCOL_VERSION) {\n        return {error: \"protocol version \" + version + \" doesn't match v2\"};\n      }\n      var deviceId = this.read_int(bytes, 1);\n      var flags = this.read_int(bytes, 3);\n      var result = {'protocol_version': version, 'device_id': deviceId};\n      // decode payload\n      var pos = 5;\n      for (i = 0; i < this.SENSORS.length; i++, flags >>= 1) {\n        if ((flags & 1) !== 1)\n          continue;\n        var sensor = this.SENSORS[i];\n        var x = [];\n        // convert data to 16-bit integer array\n        for (j = 0; j < sensor.length; j++) {\n          x.push(this.read_int(bytes, pos));\n          pos += 2;\n        }\n        // decode sensor values\n        for (j = 0; j < sensor.values.length; j++) {\n          var value = sensor.values[j];\n          if ('convert' in value) {\n            result[value.name] = {displayName: value.displayName,\n                                  value: value.convert.bind(this)(x)};\n            if ('unit' in value)\n              result[value.name]['unit'] = value.unit;\n          }\n        }\n      }\n      return result;\n    }\n  };\n\n  const decoded = decentlab_decoder.decode(payload);\n  const result = {};\n  for (var k in decoded) {\n    if (typeof decoded[k] === \"object\") {\n      result[k] = decoded[k].value;\n    } else if (typeof decoded[k] === \"number\") {\n      result[k] = decoded[k];\n    }\n  }\n  return result;\n}\n\nfunction extractNetworkTelemetry(payload) {\n  return {\n      lora_frame_counter: message.DevEUI_uplink.FCntUp,\n      lora_frame_port: message.DevEUI_uplink.FPort,\n      lora_frequency: message.DevEUI_uplink?.Frequency * 1000000,\n      lora_spreading_factor: message.DevEUI_uplink.SpFact,\n      lora_dev_eui: message.DevEUI_uplink.DevEUI,\n      lora_rssi: message.DevEUI_uplink.LrrRSSI,\n      lora_snr: message.DevEUI_uplink.LrrSNR,\n  };\n}\n\n// Helper functions\n\nfunction decodeToJson(payload) {\n  const s = String.fromCharCode.apply(String, payload);\n  return JSON.parse(s);\n}\n\nfunction parseDateToTimestamp(dateString) {\n  var timestamp = -1;\n  if (dateString != null) {\n    timestamp = new Date(dateString).getTime();\n    if (timestamp == -1) {\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('Z');\n      }\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('-');\n      }\n      if (millisecondsEndIndex == -1) {\n        if (dateString.length >= secondsSeparatorIndex + 3) {\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n        }\n      } else {\n        dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n          dateString.substring(millisecondsEndIndex, dateString.length);\n      }\n      timestamp = new Date(dateString).getTime();\n    }\n  }\n  // If we cannot parse timestamp - we will use the current timestamp\n  if (timestamp == -1) {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n\nfunction base64ToBytes(base64String) {\n  if (typeof base64String === 'string') {\n    return Uint8Array.from(atob(base64String), c => c.charCodeAt(0));\n  }\n  return [];\n}\n\nfunction keepTelemetry(telemetry) {\n  const unwanted = ['protocol_version', 'device_id', 'lora_dev_eui'];\n  return Object.fromEntries(\n    Object.entries(telemetry).filter(\n      (x) => !unwanted.includes(x[0])\n    )\n  );\n}"
  }
}