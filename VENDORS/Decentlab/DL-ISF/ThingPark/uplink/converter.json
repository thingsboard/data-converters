{
  "name": "ThingPark Uplink Decoder for Decentlab DL-ISF",
  "type": "UPLINK",
  "debugMode": true,
  "edgeTemplate": false,
  "configuration": {
    "scriptLang": "JS",
    "updateOnlyKeys": [
      "lora_frame_counter",
      "lora_frame_port",
      "lora_frequency",
      "lora_spreading_factor",
      "lora_rssi",
      "lora_dev_eui",
      "lora_snr"
    ],
    "decoder": "// WARNING: This script is designed to work with a remote JS executor. Compatibility with a local JS evaluator is not guaranteed and may require rewriting.\nconst message = decodeToJson(payload);\nconst values = Object.assign(\n  decodeDevicePayload(message.DevEUI_uplink.payload_hex),\n  extractNetworkTelemetry(message)\n);\n\nreturn {\n  deviceName: String(values.device_id),\n  deviceType: 'DL-ISF',\n  attributes: {\n    lora_dev_eui: values.lora_dev_eui,\n    protocol_version: values.protocol_version,\n  },\n  telemetry: [{\n    ts: parseDateToTimestamp(message.DevEUI_uplink.Time),\n    values: keepTelemetry(values)\n  }]\n};\n\nfunction decodeDevicePayload(payload) {\n  /* https://www.decentlab.com/products/sapflow-sensor-for-lorawan */\n  const decentlab_decoder = {\n    PROTOCOL_VERSION: 2,\n    SENSORS: [\n      {length: 16,\n       values: [{name: 'sap_flow',\n                 displayName: 'Sap flow',\n                 convert: function (x) { return (x[0] * 16 - 50000) / 1000; },\n                 unit: 'l⋅h⁻¹'},\n                {name: 'heat_velocity_outer',\n                 displayName: 'Heat velocity (outer)',\n                 convert: function (x) { return (x[1] * 16 - 50000) / 1000; },\n                 unit: 'cm⋅h⁻¹'},\n                {name: 'heat_velocity_inner',\n                 displayName: 'Heat velocity (inner)',\n                 convert: function (x) { return (x[2] * 16 - 50000) / 1000; },\n                 unit: 'cm⋅h⁻¹'},\n                {name: 'alpha_outer',\n                 displayName: 'Alpha (outer)',\n                 convert: function (x) { return (x[3] * 32 - 1000000) / 100000; }},\n                {name: 'alpha_inner',\n                 displayName: 'Alpha (inner)',\n                 convert: function (x) { return (x[4] * 32 - 1000000) / 100000; }},\n                {name: 'beta_outer',\n                 displayName: 'Beta (outer)',\n                 convert: function (x) { return (x[5] * 32 - 1000000) / 100000; }},\n                {name: 'beta_inner',\n                 displayName: 'Beta (inner)',\n                 convert: function (x) { return (x[6] * 32 - 1000000) / 100000; }},\n                {name: 'tmax_outer',\n                 displayName: 'Tmax (outer)',\n                 convert: function (x) { return (x[7] * 2) / 1000; },\n                 unit: 's'},\n                {name: 'tmax_inner',\n                 displayName: 'Tmax (inner)',\n                 convert: function (x) { return (x[8] * 2) / 1000; },\n                 unit: 's'},\n                {name: 'temperature_outer',\n                 displayName: 'Temperature (outer)',\n                 convert: function (x) { return (x[9] - 32768) / 100; },\n                 unit: '°C'},\n                {name: 'max_voltage',\n                 displayName: 'Max voltage',\n                 convert: function (x) { return (x[10] - 32768) / 1000; },\n                 unit: 'V'},\n                {name: 'min_voltage',\n                 displayName: 'Min voltage',\n                 convert: function (x) { return (x[11] - 32768) / 1000; },\n                 unit: 'V'},\n                {name: 'diagnostic',\n                 displayName: 'Diagnostic',\n                 convert: function (x) { return x[12] + x[13] * 65536; }},\n                {name: 'upstream_tmax_outer',\n                 displayName: 'Upstream Tmax (outer)',\n                 convert: function (x) { return (x[14] * 2) / 1000; },\n                 unit: 's'},\n                {name: 'upstream_tmax_inner',\n                 displayName: 'Upstream Tmax (inner)',\n                 convert: function (x) { return (x[15] * 2) / 1000; },\n                 unit: 's'}]},\n      {length: 1,\n       values: [{name: 'battery_voltage',\n                 displayName: 'Battery voltage',\n                 convert: function (x) { return x[0] / 1000; },\n                 unit: 'V'}]}\n    ],\n    read_int: function (bytes, pos) {\n      return (bytes[pos] << 8) + bytes[pos + 1];\n    },\n    decode: function (msg) {\n      var bytes = msg;\n      var i, j;\n      if (typeof msg === 'string') {\n        bytes = [];\n        for (i = 0; i < msg.length; i += 2) {\n          bytes.push(parseInt(msg.substring(i, i + 2), 16));\n        }\n      }\n      var version = bytes[0];\n      if (version != this.PROTOCOL_VERSION) {\n        return {error: \"protocol version \" + version + \" doesn't match v2\"};\n      }\n      var deviceId = this.read_int(bytes, 1);\n      var flags = this.read_int(bytes, 3);\n      var result = {'protocol_version': version, 'device_id': deviceId};\n      // decode payload\n      var pos = 5;\n      for (i = 0; i < this.SENSORS.length; i++, flags >>= 1) {\n        if ((flags & 1) !== 1)\n          continue;\n        var sensor = this.SENSORS[i];\n        var x = [];\n        // convert data to 16-bit integer array\n        for (j = 0; j < sensor.length; j++) {\n          x.push(this.read_int(bytes, pos));\n          pos += 2;\n        }\n        // decode sensor values\n        for (j = 0; j < sensor.values.length; j++) {\n          var value = sensor.values[j];\n          if ('convert' in value) {\n            result[value.name] = {displayName: value.displayName,\n                                  value: value.convert.bind(this)(x)};\n            if ('unit' in value)\n              result[value.name]['unit'] = value.unit;\n          }\n        }\n      }\n      return result;\n    }\n  };\n\n  const decoded = decentlab_decoder.decode(payload);\n  const result = {};\n  for (var k in decoded) {\n    if (typeof decoded[k] === \"object\") {\n      result[k] = decoded[k].value;\n    } else if (typeof decoded[k] === \"number\") {\n      result[k] = decoded[k];\n    }\n  }\n  return result;\n}\n\nfunction extractNetworkTelemetry(payload) {\n  return {\n      lora_frame_counter: message.DevEUI_uplink.FCntUp,\n      lora_frame_port: message.DevEUI_uplink.FPort,\n      lora_frequency: message.DevEUI_uplink?.Frequency * 1000000,\n      lora_spreading_factor: message.DevEUI_uplink.SpFact,\n      lora_dev_eui: message.DevEUI_uplink.DevEUI,\n      lora_rssi: message.DevEUI_uplink.LrrRSSI,\n      lora_snr: message.DevEUI_uplink.LrrSNR,\n  };\n}\n\n// Helper functions\n\nfunction decodeToJson(payload) {\n  const s = String.fromCharCode.apply(String, payload);\n  return JSON.parse(s);\n}\n\nfunction parseDateToTimestamp(dateString) {\n  var timestamp = -1;\n  if (dateString != null) {\n    timestamp = new Date(dateString).getTime();\n    if (timestamp == -1) {\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('Z');\n      }\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('-');\n      }\n      if (millisecondsEndIndex == -1) {\n        if (dateString.length >= secondsSeparatorIndex + 3) {\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n        }\n      } else {\n        dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n          dateString.substring(millisecondsEndIndex, dateString.length);\n      }\n      timestamp = new Date(dateString).getTime();\n    }\n  }\n  // If we cannot parse timestamp - we will use the current timestamp\n  if (timestamp == -1) {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n\nfunction base64ToBytes(base64String) {\n  if (typeof base64String === 'string') {\n    return Uint8Array.from(atob(base64String), c => c.charCodeAt(0));\n  }\n  return [];\n}\n\nfunction keepTelemetry(telemetry) {\n  const unwanted = ['protocol_version', 'device_id', 'lora_dev_eui'];\n  return Object.fromEntries(\n    Object.entries(telemetry).filter(\n      (x) => !unwanted.includes(x[0])\n    )\n  );\n}"
  }
}