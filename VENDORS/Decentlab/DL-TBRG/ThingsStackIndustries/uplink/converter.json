{
  "name": "Things Stack Industries Uplink Converter for Decentlab DL-TBRG",
  "type": "UPLINK",
  "debugMode": true,
  "edgeTemplate": false,
  "configuration": {
    "scriptLang": "JS",
    "updateOnlyKeys": [
      "lora_frame_counter",
      "lora_frame_port",
      "lora_frequency",
      "lora_spreading_factor",
      "lora_rssi",
      "lora_dev_eui",
      "lora_snr"
    ],
    "decoder": "// WARNING: This script is designed to work with a remote JS executor. Compatibility with a local JS evaluator is not guaranteed and may require rewriting.\n\nconst message = decodeToJson(payload);\nconst values = Object.assign(\n  decodeDevicePayload(base64ToBytes(message.uplink_message.frm_payload)),\n  extractNetworkTelemetry(message)\n);\n\nreturn {\n  deviceName: String(values.device_id),\n  deviceType: 'DL-TBRG',\n  attributes: {\n    lora_dev_eui: values.lora_dev_eui,\n    protocol_version: values.protocol_version,\n  },\n  telemetry: [{\n    ts: parseDateToTimestamp(message.received_at),\n    values: keepTelemetry(values)\n  }]\n};\n\nfunction decodeDevicePayload(payload) {\n  /* https://www.decentlab.com/products/tipping-bucket-rain-gauge-for-lorawan */\n  const decentlab_decoder = {\n    PROTOCOL_VERSION: 2,\n    /* device-specific parameters */\n    PARAMETERS: {\n      resolution: 0.1\n    },\n    SENSORS: [\n      {length: 4,\n       values: [{name: 'precipitation',\n                 displayName: 'Precipitation',\n                 convert: function (x) { return x[0] * this.PARAMETERS.resolution; },\n                 unit: 'mm'},\n                {name: 'precipitation_interval',\n                 displayName: 'Precipitation interval',\n                 convert: function (x) { return x[1]; },\n                 unit: 's'},\n                {name: 'cumulative_precipitation',\n                 displayName: 'Cumulative precipitation',\n                 convert: function (x) { return (x[2] + x[3] * 65536) * this.PARAMETERS.resolution; },\n                 unit: 'mm'}]},\n      {length: 1,\n       values: [{name: 'battery_voltage',\n                 displayName: 'Battery voltage',\n                 convert: function (x) { return x[0] / 1000; },\n                 unit: 'V'}]}\n    ],\n    read_int: function (bytes, pos) {\n      return (bytes[pos] << 8) + bytes[pos + 1];\n    },\n    decode: function (msg) {\n      var bytes = msg;\n      var i, j;\n      if (typeof msg === 'string') {\n        bytes = [];\n        for (i = 0; i < msg.length; i += 2) {\n          bytes.push(parseInt(msg.substring(i, i + 2), 16));\n        }\n      }\n      var version = bytes[0];\n      if (version != this.PROTOCOL_VERSION) {\n        return {error: \"protocol version \" + version + \" doesn't match v2\"};\n      }\n      var deviceId = this.read_int(bytes, 1);\n      var flags = this.read_int(bytes, 3);\n      var result = {'protocol_version': version, 'device_id': deviceId};\n      // decode payload\n      var pos = 5;\n      for (i = 0; i < this.SENSORS.length; i++, flags >>= 1) {\n        if ((flags & 1) !== 1)\n          continue;\n        var sensor = this.SENSORS[i];\n        var x = [];\n        // convert data to 16-bit integer array\n        for (j = 0; j < sensor.length; j++) {\n          x.push(this.read_int(bytes, pos));\n          pos += 2;\n        }\n        // decode sensor values\n        for (j = 0; j < sensor.values.length; j++) {\n          var value = sensor.values[j];\n          if ('convert' in value) {\n            result[value.name] = {displayName: value.displayName,\n                                  value: value.convert.bind(this)(x)};\n            if ('unit' in value)\n              result[value.name]['unit'] = value.unit;\n          }\n        }\n      }\n      return result;\n    }\n  };\n\n  const decoded = decentlab_decoder.decode(payload);\n  const result = {};\n  for (var k in decoded) {\n    if (typeof decoded[k] === \"object\") {\n      result[k] = decoded[k].value;\n    } else if (typeof decoded[k] === \"number\") {\n      result[k] = decoded[k];\n    }\n  }\n  return result;\n}\n\nfunction extractNetworkTelemetry(payload) {\n  const result = {\n    lora_frame_counter: message.uplink_message.f_cnt,\n    lora_frame_port: message.uplink_message.f_port,\n    lora_frequency: parseInt(message.uplink_message.settings.frequency),\n    lora_dev_eui: message.end_device_ids.dev_eui,\n    lora_spreading_factor:\n      message.uplink_message.settings.data_rate.lora.spreading_factor,\n  };\n  const gwi = message.uplink_message.rx_metadata\n    .map((x) => ({ lora_rssi: x.rssi, lora_snr: x.snr }))\n    .reduce((a, x) => (x.lora_rssi > a.lora_rssi ? x : a), {\n      lora_rssi: -Number.MAX_VALUE,\n    });\n  return Object.assign(result, gwi);\n}\n\n// Helper functions\n\nfunction decodeToJson(payload) {\n  const s = String.fromCharCode.apply(String, payload);\n  return JSON.parse(s);\n}\n\nfunction parseDateToTimestamp(dateString) {\n  var timestamp = -1;\n  if (dateString != null) {\n    timestamp = new Date(dateString).getTime();\n    if (timestamp == -1) {\n      var secondsSeparatorIndex = dateString.lastIndexOf('.') + 1;\n      var millisecondsEndIndex = dateString.lastIndexOf('+');\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('Z');\n      }\n      if (millisecondsEndIndex == -1) {\n        millisecondsEndIndex = dateString.lastIndexOf('-');\n      }\n      if (millisecondsEndIndex == -1) {\n        if (dateString.length >= secondsSeparatorIndex + 3) {\n          dateString = dateString.substring(0, secondsSeparatorIndex + 3);\n        }\n      } else {\n        dateString = dateString.substring(0, secondsSeparatorIndex + 3) +\n          dateString.substring(millisecondsEndIndex, dateString.length);\n      }\n      timestamp = new Date(dateString).getTime();\n    }\n  }\n  // If we cannot parse timestamp - we will use the current timestamp\n  if (timestamp == -1) {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n\nfunction base64ToBytes(base64String) {\n  if (typeof base64String === 'string') {\n    return Uint8Array.from(atob(base64String), c => c.charCodeAt(0));\n  }\n  return [];\n}\n\nfunction keepTelemetry(telemetry) {\n  const unwanted = ['protocol_version', 'device_id', 'lora_dev_eui'];\n  return Object.fromEntries(\n    Object.entries(telemetry).filter(\n      (x) => !unwanted.includes(x[0])\n    )\n  );\n}"
  }
}